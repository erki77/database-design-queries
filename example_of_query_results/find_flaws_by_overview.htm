<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="find_flaws_by_overview_files/queries.css">
<div class="medium_line_spacing">

<title>System of queries</title>
<p>Queries, in addition to those in the "Quick test", that could point to the mistakes in the database but require review by human.</p><p></p><p>The test contains <b><big><font color="red">151</font></big></b> queries.</p><p><i>Seq nr:</i> 1<br><i>Query:</i> <b>The number of schema objects by schema, by type, and in total</b><br><i>General goal:</i>
 Find the number of different types of schema objects in different 
schemas as well as the total number of schema objects. Show the number 
of objects that belong to an extension as well as the number of 
(user-defined) objects that do not belong to an extension.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">schema_name</th><th class="tv">type</th><th class="tv">number_of_objects_in_an_extension</th><th class="tv">number_of_user_defined_objects</th><th class="tv">total_number_of_objects</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">BASE TYPE</td><td class="table_results">0</td><td class="table_results">3</td><td class="table_results">3</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">COMPOSITE TYPE</td><td class="table_results">0</td><td class="table_results">5</td><td class="table_results">5</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">INDEX</td><td class="table_results">0</td><td class="table_results">3</td><td class="table_results">3</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">public</td><td class="table_results">SEQUENCE GENERATOR</td><td class="table_results">0</td><td class="table_results">2</td><td class="table_results">2</td></tr><tr class="tv1"><td class="table_results">5</td><td class="table_results">public</td><td class="table_results">TABLE</td><td class="table_results">0</td><td class="table_results">3</td><td class="table_results">3</td></tr><tr class="tv2"><td class="table_results">6</td><td class="table_results">public</td><td class="table_results">&nbsp;</td><td class="table_results">0</td><td class="table_results">16</td><td class="table_results">16</td></tr><tr class="tv1"><td class="table_results">7</td><td class="table_results">&nbsp;</td><td class="table_results">BASE TYPE</td><td class="table_results">0</td><td class="table_results">3</td><td class="table_results">3</td></tr><tr class="tv2"><td class="table_results">8</td><td class="table_results">&nbsp;</td><td class="table_results">COMPOSITE TYPE</td><td class="table_results">0</td><td class="table_results">5</td><td class="table_results">5</td></tr><tr class="tv1"><td class="table_results">9</td><td class="table_results">&nbsp;</td><td class="table_results">INDEX</td><td class="table_results">0</td><td class="table_results">3</td><td class="table_results">3</td></tr><tr class="tv2"><td class="table_results">10</td><td class="table_results">&nbsp;</td><td class="table_results">SEQUENCE GENERATOR</td><td class="table_results">0</td><td class="table_results">2</td><td class="table_results">2</td></tr><tr class="tv1"><td class="table_results">11</td><td class="table_results">&nbsp;</td><td class="table_results">TABLE</td><td class="table_results">0</td><td class="table_results">3</td><td class="table_results">3</td></tr><tr class="tv2"><td class="table_results">12</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td><td class="table_results">0</td><td class="table_results">16</td><td class="table_results">16</td></tr></tbody></table></p><p>Query result generated in 0.0107 seconds.</p><p><i>Seq nr:</i> 2<br><i>Query:</i> <b>The number of tables by schema, by type, and in total</b><br><i>General goal:</i> Find the number of tables (base, foreign, and derived) in different schemas.<br><i>Goal in the test:</i> <b>Overview. Requirement is to have at least seven base tables and three views.</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_type</th><th class="tv">number_of_tables</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">BASE TABLE</td><td class="table_results">3</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">&nbsp;</td><td class="table_results">3</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">&nbsp;</td><td class="table_results">BASE TABLE</td><td class="table_results">3</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td><td class="table_results">3</td></tr></tbody></table></p><p>Query result generated in 0.0022 seconds.</p><p><i>Seq nr:</i> 3<br><i>Query:</i> <b>The number of columns based on table type</b><br><i>General goal:</i> Find the total number of columns in the different types of tables as well as average number of columns in the tables.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">total_nr_of_base_table_cols</th><th class="tv">average_nr_of_cols_base_table</th><th class="tv">the_biggest_nr_of_cols_in_a_base_table</th><th class="tv">total_nr_of_view_cols</th><th class="tv">average_nr_of_cols_view</th><th class="tv">the_biggest_nr_of_cols_in_a_view</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">13</td><td class="table_results">4.3</td><td class="table_results">6</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr></tbody></table></p><p>Query result generated in 0.014 seconds.</p><p><i>Seq nr:</i> 4<br><i>Query:</i> <b>The number of constraints by schema, by type, and in total</b><br><i>General goal:</i>
 Find the number of constraints in different schemas. The number of 
constraints in a database gives an indication about the state of 
enforcing constraints at the database level.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">schema</th><th class="tv">con_type</th><th class="tv">number_of_constraints</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">FOREIGN KEY</td><td class="table_results">1</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">PRIMARY KEY</td><td class="table_results">3</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">TABLE CHECK</td><td class="table_results">6</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">public</td><td class="table_results">&nbsp;</td><td class="table_results">10</td></tr><tr class="tv1"><td class="table_results">5</td><td class="table_results">&nbsp;</td><td class="table_results">FOREIGN KEY</td><td class="table_results">1</td></tr><tr class="tv2"><td class="table_results">6</td><td class="table_results">&nbsp;</td><td class="table_results">PRIMARY KEY</td><td class="table_results">3</td></tr><tr class="tv1"><td class="table_results">7</td><td class="table_results">&nbsp;</td><td class="table_results">TABLE CHECK</td><td class="table_results">6</td></tr><tr class="tv2"><td class="table_results">8</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td><td class="table_results">10</td></tr></tbody></table></p><p>Query result generated in 0.0022 seconds.</p><p><i>Seq nr:</i> 5<br><i>Query:</i> <b>The number of user-defined rules by schema and in total</b><br><i>General goal:</i>
 Find the number of rules in a database in different schemas, excluding 
the rules that are created to support views. Rules can be used to 
maintain data integrity in a database by causing rejection of incorrect 
insertions and updates. Therefore, the number of rules in a database 
gives an indication about the state of enforcing constraints at the 
database level.<br><i>Goal in the test:</i> <b>Overview. Requirement is to have at least two triggers or rules</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://www.postgresql.org/docs/current/rules-views.html">https://www.postgresql.org/docs/current/rules-views.html</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">schemaname</th><th class="tv">number_of_rules</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">&nbsp;</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0013 seconds.</p><p><i>Seq nr:</i> 6<br><i>Query:</i> <b>The number of user-defined triggers by schema, by type, and in total</b><br><i>General goal:</i>
 Triggers can be used to maintain data integrity in a database by 
causing rejection of data that does not conform to certain rules. 
Therefore, the number of triggers in a database gives an indication 
about the state of enforcing constraints at the database level.<br><i>Goal in the test:</i> <b>Overview. Requirement is to have at least two triggers or rules.</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">trigger_schema</th><th class="tv">trigger_type</th><th class="tv">number_of_triggers</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0022 seconds.</p><p><i>Seq nr:</i> 7<br><i>Query:</i> <b>Installed extensions</b><br><i>General goal:</i>
 Try to use as much the possibilities of the DBMS as possible. On the 
other hand, do not install extensions that are not needed in order not 
to overcomplicate the database.<br><i>Goal in the test:</i> <b>Overview. Most of you will need at least the pgcrypto extension (see the exercise 10).</b><br><i>Reference materials:</i> </p><ul><li>There are quite a lot of extensions that are <a target="_blank" href="https://www.postgresql.org/docs/current/external-extensions.html">shipped together with the PostgreSQL source code</a>.</li><li>Anyone can create an extension and there are many examples: <a target="_blank" href="https://pgxn.org/">https://pgxn.org/</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">name</th><th class="tv">installed_version</th><th class="tv">comment</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">plpgsql</td><td class="table_results">1.0</td><td class="table_results">PL/pgSQL procedural language</td></tr></tbody></table></p><p>Query result generated in 0.0109 seconds.</p><p><i>Fixing suggestion:</i> If you do not need an extension, then drop it.<br><i>A fixing action:</i> Drop the extension.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">DROP EXTENSION plpgsql;</textarea></p><p><i>Seq nr:</i> 8<br><i>Query:</i> <b>Extensions that are available but are not installed</b><br><i>General goal:</i>
 Try to use as much the possibilities of the DBMS as possible. On the 
other hand, do not install extensions that are not needed in order not 
to overcomplicate the database.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://www.postgresql.org/docs/current/contrib.html">https://www.postgresql.org/docs/current/contrib.html</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">name</th><th class="tv">comment</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">btree_gist</td><td class="table_results">support for indexing common datatypes in GiST</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">citext</td><td class="table_results">data type for case-insensitive character strings</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">cube</td><td class="table_results">data type for multidimensional cubes</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">dblink</td><td class="table_results">connect to other PostgreSQL databases from within a database</td></tr><tr class="tv1"><td class="table_results">5</td><td class="table_results">earthdistance</td><td class="table_results">calculate great-circle distances on the surface of the Earth</td></tr><tr class="tv2"><td class="table_results">6</td><td class="table_results">file_fdw</td><td class="table_results">foreign-data wrapper for flat file access</td></tr><tr class="tv1"><td class="table_results">7</td><td class="table_results">fuzzystrmatch</td><td class="table_results">determine similarities and distance between strings</td></tr><tr class="tv2"><td class="table_results">8</td><td class="table_results">hstore</td><td class="table_results">data type for storing sets of (key, value) pairs</td></tr><tr class="tv1"><td class="table_results">9</td><td class="table_results">ltree</td><td class="table_results">data type for hierarchical tree-like structures</td></tr><tr class="tv2"><td class="table_results">10</td><td class="table_results">pageinspect</td><td class="table_results">inspect the contents of database pages at a low level</td></tr><tr class="tv1"><td class="table_results">11</td><td class="table_results">pg_trgm</td><td class="table_results">text similarity measurement and index searching based on trigrams</td></tr><tr class="tv2"><td class="table_results">12</td><td class="table_results">pgcrypto</td><td class="table_results">cryptographic functions</td></tr><tr class="tv1"><td class="table_results">13</td><td class="table_results">postgres_fdw</td><td class="table_results">foreign-data wrapper for remote PostgreSQL servers</td></tr><tr class="tv2"><td class="table_results">14</td><td class="table_results">tablefunc</td><td class="table_results">functions that manipulate whole tables, including crosstab</td></tr></tbody></table></p><p>Query result generated in 0.0013 seconds.</p><p><i>Fixing suggestion:</i> If you need an extension, then install it.<br><i>A fixing action:</i> Install the extension in the current default object creation schema.<br><textarea readonly="readonly" cols="100" rows="5" wrap="off">CREATE EXTENSION btree_gist;
CREATE EXTENSION citext;
CREATE EXTENSION cube;
CREATE EXTENSION dblink;
CREATE EXTENSION earthdistance;
CREATE EXTENSION file_fdw;
CREATE EXTENSION fuzzystrmatch;
CREATE EXTENSION hstore;
CREATE EXTENSION ltree;
CREATE EXTENSION pageinspect;
CREATE EXTENSION pg_trgm;
CREATE EXTENSION pgcrypto;
CREATE EXTENSION postgres_fdw;
CREATE EXTENSION tablefunc;</textarea></p><p><i>Seq nr:</i> 9<br><i>Query:</i> <b>The same database object name is used repeatedly within the same database object type</b><br><i>General goal:</i>
 Find what database object names are used more than once within the 
objects of the same type. If the names differ from each other only by 
digits or subscripts, then consider these the same name. For instance, 
if there are base tables Person and Person2 (in the same schema or 
different schemas), then the query returns the name Person. Make sure 
that there is no duplication of implementation elements in the database.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">object_type</th><th class="tv">number_of_occurrences</th><th class="tv">name_without_digits_subscripts</th><th class="tv">objects</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">TABLE CHECK</td><td class="table_results">2</td><td class="table_results">chkcode</td><td class="table_results">BASE TABLE.public.person_state_type.chk_code;<br>BASE TABLE.public.public_person_data.chk_code</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">TABLE CHECK</td><td class="table_results">2</td><td class="table_results">chkpersondatalastname</td><td class="table_results">BASE TABLE.public.public_person_data.chk_person_data_last_name;<br>BASE TABLE.public.public_person_data.chk_person_data_last_name2</td></tr></tbody></table></p><p>Query result generated in 0.0118 seconds.</p><p><i>Seq nr:</i> 10<br><i>Query:</i> <b>Logical size of a table</b><br><i>General goal:</i> The table size is the sum of the total size of the simple columns and the total size of the complex columns in the table.<br><i>Goal in the test:</i> <b>Overview. Too large tables are suspicious (probably not highly normalized)</b><br><i>Reference materials:</i> </p><ul><li>Piattini, M., Calero, C., Sahraoui, H. A., &amp; Lounis, H. (2001). Object-relational database metrics. L'Objet, 7(4), 477-496.</li><li>Rule
 11 in: Delplanque, J., Etien, A., Auverlot, O., Mens, T., Anquetil, N.,
 Ducasse, S.: CodeCritics applied to database schema: Challenges and 
first results. In: 2017 IEEE 24th International Conference on Software 
Analysis, Evolution and Reengineering (SANER), pp. 432-436. IEEE, 
(2017).</li><li>Smell "God table": Sharma, T., Fragkoulis, M., Rizou, 
S., Bruntink, M. and Spinellis, D.: Smelly relations: measuring and 
understanding database schema quality. In: Proceedings of the 40th 
International Conference on Software Engineering: Software Engineering 
in Practice, pp. 55-64. ACM, (2018).</li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_type</th><th class="tv">table_name</th><th class="tv">ts</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">BASE TABLE</td><td class="table_results">comment</td><td class="table_results">6</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">BASE TABLE</td><td class="table_results">public_person_data</td><td class="table_results">5</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">BASE TABLE</td><td class="table_results">person_state_type</td><td class="table_results">2</td></tr></tbody></table></p><p>Query result generated in 0.0353 seconds.</p><p><i>Seq nr:</i> 11<br><i>Query:</i> <b>The number of names that use different writing styles</b><br><i>General goal:</i>
 Find the number of names of user-defined database objects that use 
snake_case, ALL CAPS, Sentence case, camelCase or PascalCase style. Make
 sure that the naming style is consistent.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://en.wikipedia.org/wiki/Camel_case">https://en.wikipedia.org/wiki/Camel_case</a></li><li><a target="_blank" href="http://wiki.c2.com/?PascalCase">http://wiki.c2.com/?PascalCase</a></li><li><a target="_blank" href="https://en.wikipedia.org/wiki/Snake_case">https://en.wikipedia.org/wiki/Snake_case</a></li><li><a target="_blank" href="https://en.wikipedia.org/wiki/Letter_case">https://en.wikipedia.org/wiki/Letter_case</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">number_of_names_with_snake_case</th><th class="tv">number_of_names_with_all_caps</th><th class="tv">number_of_names_with_sentence_case</th><th class="tv">number_of_names_with_camel_case</th><th class="tv">number_of_names_with_pascal_case</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">26</td><td class="table_results">0</td><td class="table_results">0</td><td class="table_results">0</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0364 seconds.</p><p><i>Seq nr:</i> 12<br><i>Query:</i> <b>Too generic names (table constraints)</b><br><i>General goal:</i>
 Find table constraints (constraints that are associated directly with 
the table) that have too generic names like "constraint" or the name 
contain too generic words like "data" (all constraints restrict data in 
the table), or the name is an abbreviation of the constraint type name.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br>The query found <b><font color="red">2</font></b> rows!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">table_type</th><th class="tv">suspected_constraint_type</th><th class="tv">suspected_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">TABLE CHECK</td><td class="table_results">chk_person_data_last_name</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">TABLE CHECK</td><td class="table_results">chk_person_data_last_name2</td></tr></tbody></table></p><p>Query result generated in 0.0016 seconds.</p><p><i>Fixing suggestion:</i> Rename the constraints.</p><p><i>Seq nr:</i> 13<br><i>Query:</i> <b>Using unreserved SQL keywords as the names of a database object</b><br><i>General goal:</i>
 "Names in software are 90 percent of what make software readable. You 
need to take the time to choose them wisely and keep them relevant. 
Names are too important to treat carelessly. Names should not cause 
confusion." (Robert C. Martin, Clean Code) Find the names (identifiers) 
of user-defined objects that are SQL keywords that are completely 
unreserved, i.e., these have absolutely no special status in the 
PostgreSQL parser. Nevertheless, think as to whether some better name 
would be possible.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reliability of the results:</i> Low (Many false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://www.postgresql.org/docs/current/sql-keywords-appendix.html">https://www.postgresql.org/docs/current/sql-keywords-appendix.html</a></li><li>Perhaps
 the names are too general. The corresponding code smells in case of 
cleaning code are "N1: Choose Descriptive Names", "N2: Choose Names at 
the Appropriate Level of Abstraction", "N4: Unambiguous Names", "N7: 
Names Should Describe Side-Effects". (Robert C. Martin, Clean Code)</li><li>Smell
 "Meaningless name": Sharma, T., Fragkoulis, M., Rizou, S., Bruntink, M.
 and Spinellis, D.: Smelly relations: measuring and understanding 
database schema quality. In: Proceedings of the 40th International 
Conference on Software Engineering: Software Engineering in Practice, 
pp. 55-64. ACM, (2018).</li></ul><br>The query found <b><font color="red">2</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">container_name</th><th class="tv">container_type</th><th class="tv">suspected_name</th><th class="tv">suspected_object_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">SCHEMA</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public.person_state_type</td><td class="table_results">BASE TABLE</td><td class="table_results">name</td><td class="table_results">COLUMN</td></tr></tbody></table></p><p>Query result generated in 0.0381 seconds.</p><p><i>Fixing suggestion:</i> Perhaps in case of some database objects a more descriptive name would be possible.</p><p><i>Seq nr:</i> 14<br><i>Query:</i> <b>Names of database objects that contain a digit</b><br><i>General goal:</i>
 Find the names (identifiers) of user-defined database objects that 
contain at least one digit. Names should be informative. Duplicates 
should be avoided. Digits in names are a possible sign of duplication of
 database objects or unclear names.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li>The
 use of digits in names is a sign of the following antipatterns from the
 Bill Karwin's book of SQL antipatterns: Multicolumn Attributes (Chapter
 8), Metadata Tribbles (Chapter 9).</li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">container_name</th><th class="tv">container_type</th><th class="tv">suspected_name</th><th class="tv">object_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public.public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">chk_person_data_last_name<b>2</b></td><td class="table_results">TABLE CHECK</td></tr></tbody></table></p><p>Query result generated in 0.0318 seconds.</p><p><i>Seq nr:</i> 15<br><i>Query:</i> <b>Table constraints with the same name (constraints connected directly with a base table or a foreign table)</b><br><i>General goal:</i>
 Find base table and foreign table constraint names that are used in a 
database more than once (possibly in different schemas or in case of 
different types of constraints). Different things should have different 
names. But here different constraints have the same name. Also make sure
 that this is not a sign of duplication.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://dba.stackexchange.com/questions/152510/enforce-constraint-name-uniqueness">https://dba.stackexchange.com/questions/152510/enforce-constraint-name-uniqueness</a></li><li><a target="_blank" href="https://www.postgresql.org/message-id/3724.1094436837%40sss.pgh.pa.us">https://www.postgresql.org/message-id/3724.1094436837%40sss.pgh.pa.us</a></li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">conname</th><th class="tv">number_of_appearances</th><th class="tv">tables</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">chk_code</td><td class="table_results">2</td><td class="table_results">BASE TABLE.public.person_state_type (CHECK);<br>BASE TABLE.public.public_person_data (CHECK)</td></tr></tbody></table></p><p>Query result generated in 0.0019 seconds.</p><p><i>Fixing suggestion:</i> Rename the constraints so that the name is unique within a schema. Follow a naming convention.</p><p><i>Seq nr:</i> 16<br><i>Query:</i> <b>Number of system-generated constraint names by constraint type (constraints that involve one column)</b><br><i>General goal:</i>
 Find the number of system-generated constraint names by constraint 
type. Names should follow the same style. If there is a mix of 
system-generated and user-defined names, then the style is most probably
 different.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">type</th><th class="tv">cnt_system_generated</th><th class="tv">cnt_all</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">CHECK</td><td class="table_results">0</td><td class="table_results">5</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">EXCLUDE</td><td class="table_results">0</td><td class="table_results">0</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">FOREIGN KEY</td><td class="table_results">0</td><td class="table_results">1</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">PRIMARY KEY</td><td class="table_results">2</td><td class="table_results">3</td></tr><tr class="tv1"><td class="table_results">5</td><td class="table_results">UNIQUE</td><td class="table_results">0</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0051 seconds.</p><p><i>Seq nr:</i> 17<br><i>Query:</i> <b>Table constraints with the cardinality bigger than one</b><br><i>General goal:</i> Find constraints that involve more than one columns. Check as to whether the names follow a common style or not.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">cardinality</th><th class="tv">type</th><th class="tv">schema_name</th><th class="tv">table_name</th><th class="tv">constraint_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">2</td><td class="table_results">CHECK</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_check</td></tr></tbody></table></p><p>Query result generated in 0.0045 seconds.</p><p><i>Seq nr:</i> 18<br><i>Query:</i> <b>Patterns
 of the names of PRIMARY KEY, UNIQUE, CHECK, EXCLUDE, and FOREIGN KEY 
constraints as well as user-defined non-unique indexes that are 
associated with exactly one column</b><br><i>General goal:</i> Find patterns of the names of constraints and indexes. Make sure that the naming is consistent.<br><i>Goal in the test:</i> <b>Overview. The fewer, the better. The more there are patterns, especially with the number_of_occurrences=1, the worse.</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">pattern</th><th class="tv">types</th><th class="tv">number_of_occurrences</th><th class="tv">names</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">chk_code</td><td class="table_results">CHECK</td><td class="table_results">2</td><td class="table_results">chk_code (person_state_type.person_state_type_code);<br>chk_code (public_person_data.persons_state_type_code)</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">chk_<b>table</b>_<b>column</b></td><td class="table_results">CHECK</td><td class="table_results">1</td><td class="table_results">chk_person_state_type_name (person_state_type.name)</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">chk_person_data_<b>column</b></td><td class="table_results">CHECK</td><td class="table_results">1</td><td class="table_results">chk_person_data_last_name (public_person_data.last_name)</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">chk_person_data_<b>column</b>2</td><td class="table_results">CHECK</td><td class="table_results">1</td><td class="table_results">chk_person_data_last_name2 (public_person_data.last_name)</td></tr><tr class="tv1"><td class="table_results">5</td><td class="table_results">fk_person <b>primarytab</b></td><td class="table_results">FOREIGN KEY</td><td class="table_results">1</td><td class="table_results">FK_person
 person_state_type (primary: person_state_type.person_state_type_code 
child: public_person_data.persons_state_type_code)</td></tr><tr class="tv2"><td class="table_results">6</td><td class="table_results"><b>table</b>_pkey</td><td class="table_results">PRIMARY KEY</td><td class="table_results">2</td><td class="table_results">comment_pkey (comment.comment_id);<br>person_state_type_pkey (person_state_type.person_state_type_code)</td></tr><tr class="tv1"><td class="table_results">7</td><td class="table_results">pk_person</td><td class="table_results">PRIMARY KEY</td><td class="table_results">1</td><td class="table_results">pk_person (public_person_data.id)</td></tr></tbody></table></p><p>Query result generated in 0.0103 seconds.</p><p><i>Seq nr:</i> 19<br><i>Query:</i> <b>Column names that make joining tables more difficult</b><br><i>General goal:</i>
 Find foreign keys where the name of the foreign key column and the 
corresponding primary key/unique column is different. Exclude foreign 
key columns that refer to the key of the same table because within each 
named table column names must be different. Simplify writing queries 
that have to join data from multiple base tables. If the columns that 
participate in the join condition have the same name, then in case of 
inner join one does not have to write a long join condition but instead 
can use USING syntax.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Low (Many false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">conname</th><th class="tv_small">foreign_schema</th><th class="tv_small">foreign_table</th><th class="tv_small">foreign_col</th><th class="tv_small">target_schema</th><th class="tv_small">target_table</th><th class="tv_small">target_col</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">FK_person person_state_type</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">person_state_type_code</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">persons_state_type_code</td></tr></tbody></table></p><p>Query result generated in 0.0019 seconds.</p><p><i>Fixing suggestion:</i>
 If the difference is unintentional and minor, then change the names so 
that these would be identical. On the other hand, if the foreign key 
column name describes the role of the entity type in the context of the 
implemented relationship type, then no renaming is needed.</p><p><i>Seq nr:</i> 20<br><i>Query:</i> <b>Consistency of using generic column names (non-foreign key and non-candidate key columns)</b><br><i>General goal:</i>
 Find the names on base table columns that are not a part of a candidate
 key and a foreign key and contain a generic word (nimi, nimetus, 
kommentaar, kirjeldus, name, comment, description). Make sure that 
naming of these is consistent, i.e., such names always contain the table
 name or never contain the table name.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li>The corresponding code smell in case of cleaning code is "N4: Unambiguous Names". (Robert C. Martin, Clean Code)</li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">name</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">first_name</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">last_name</td></tr></tbody></table></p><p>Query result generated in 0.0156 seconds.</p><p><i>Fixing suggestion:</i> If the naming is inconsistent, then make it consistent.</p><p><i>Seq nr:</i> 21<br><i>Query:</i> <b>Names of columns with the type BOOLEAN</b><br><i>General goal:</i>
 The naming of BOOLEAN columns must be consistent. For the better 
readability the names of such columns could have prefix "is_" (in 
English) or "on_" (in Estonian)<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">table_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">active</td><td class="table_results">BASE TABLE</td></tr></tbody></table></p><p>Query result generated in 0.0069 seconds.</p><p><i>Fixing suggestion:</i> Use a consistent naming style and rename the column if needed.</p><p><i>Seq nr:</i> 22<br><i>Query:</i> <b>Names of database objects that are used to manage the state of main objects in the database</b><br><i>General goal:</i>
 "Names in software are 90 percent of what make software readable. You 
need to take the time to choose them wisely and keep them relevant. 
Names are too important to treat carelessly. Names should not cause 
confusion." (Robert C. Martin, Clean Code) The naming must be 
consistent. One should avoid mixing synonyms like "seisund", "staatus", 
and "olek" in Estonian or "state" and "status" in English and stick with
 one term.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">container_name</th><th class="tv">container_type</th><th class="tv">suspected_name</th><th class="tv">suspected_object_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">SCHEMA</td><td class="table_results">person_<b>state</b>_type</td><td class="table_results">BASE TABLE</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public.person_state_type</td><td class="table_results">BASE TABLE</td><td class="table_results">person_<b>state</b>_type_code</td><td class="table_results">COLUMN</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public.public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">persons_<b>state</b>_type_code</td><td class="table_results">COLUMN</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">public.public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">FK_person person_<b>state</b>_type</td><td class="table_results">FOREIGN KEY</td></tr><tr class="tv1"><td class="table_results">5</td><td class="table_results">public</td><td class="table_results">SCHEMA</td><td class="table_results">person_<b>state</b>_type_pkey</td><td class="table_results">INDEX</td></tr><tr class="tv2"><td class="table_results">6</td><td class="table_results">public.person_state_type</td><td class="table_results">BASE TABLE</td><td class="table_results">person_<b>state</b>_type_pkey</td><td class="table_results">PRIMARY KEY</td></tr><tr class="tv1"><td class="table_results">7</td><td class="table_results">public.person_state_type</td><td class="table_results">BASE TABLE</td><td class="table_results">chk_person_<b>state</b>_type_name</td><td class="table_results">TABLE CHECK</td></tr></tbody></table></p><p>Query result generated in 0.0339 seconds.</p><p><i>Seq nr:</i> 23<br><i>Query:</i> <b>All key constraints</b><br><i>General goal:</i> Find all the primary key and unique constraints of base tables.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">conname</th><th class="tv">key_schema</th><th class="tv">key_table</th><th class="tv">contype</th><th class="tv">key_col</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">comment_pkey</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">PRIMARY KEY</td><td class="table_results">{comment_id}</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">person_state_type_pkey</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">PRIMARY KEY</td><td class="table_results">{person_state_type_code}</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">pk_person</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">PRIMARY KEY</td><td class="table_results">{id}</td></tr></tbody></table></p><p>Query result generated in 0.0026 seconds.</p><p><i>Seq nr:</i> 24<br><i>Query:</i> <b>The number and percentage of base tables without keys</b><br><i>General goal:</i>
 Find the extent in which repeating rows are permitted in the database. 
Find the number and percentage (from the total number of base tables) of
 base tables that do not have the PRIMARY KEY constraint and also do not
 have any UNIQUE constraints.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://www.red-gate.com/simple-talk/sql/database-administration/five-simple-database-design-errors-you-should-avoid/">https://www.red-gate.com/simple-talk/sql/database-administration/five-simple-database-design-errors-you-should-avoid/</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">number_of_base_tables_without_keys</th><th class="tv">number_of_base_tables</th><th class="tv">percentage_of_base_tables_without_keys</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">0</td><td class="table_results">3</td><td class="table_results">0.0</td></tr></tbody></table></p><p>Query result generated in 0.0048 seconds.</p><p><i>Seq nr:</i> 25<br><i>Query:</i> <b>Base tables with exactly one key</b><br><i>General goal:</i>
 Find all base tables that have exactly one PRIMARY KEY or UNIQUE 
constraint. Find and enforce all the keys. Are you sure there are not 
more keys in the table?<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">key_schema</th><th class="tv">key_table</th><th class="tv">contype</th><th class="tv">key_col</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">PRIMARY KEY</td><td class="table_results">comment_id</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">PRIMARY KEY</td><td class="table_results">person_state_type_code</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">PRIMARY KEY</td><td class="table_results">id</td></tr></tbody></table></p><p>Query result generated in 0.0015 seconds.</p><p><i>Seq nr:</i> 26<br><i>Query:</i> <b>Do not use approach that one size fits all (primary key columns)</b><br><i>General goal:</i>
 Find base base tables have the simple primary key that contains a 
column with the (case insensitive) name id and type INTEGER (or 
similar). In addition, the primary key values are generated 
automatically by the system.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li>This is one of the antipatterns from the Bill Karwin's book of SQL antipatterns. See Chapter 4: ID Required.</li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td></tr></tbody></table></p><p>Query result generated in 0.0194 seconds.</p><p><i>Seq nr:</i> 27<br><i>Query:</i> <b>Base tables that have a surrogate key as the primary key and do not have any unique constraints</b><br><i>General goal:</i>
 A surrogate key is a primary key that consist of one column. The values
 of this column do not have any meaning for the user and the system 
usually generates the values (integers) automatically. In case of 
defining a surrogate key in a table it is a common mistake to forget 
declaring existing natural keys in the table. The query discards tables 
with only one column.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br><i>Reference materials:</i> </p><ul><li>Smell
 "Superfluous key": Sharma, T., Fragkoulis, M., Rizou, S., Bruntink, M. 
and Spinellis, D.: Smelly relations: measuring and understanding 
database schema quality. In: Proceedings of the 40th International 
Conference on Software Engineering: Software Engineering in Practice, 
pp. 55-64. ACM, (2018).</li></ul><br>The query found <b><font color="red">2</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td></tr></tbody></table></p><p>Query result generated in 0.0271 seconds.</p><p><i>Fixing suggestion:</i>
 Find and enforce natural keys, i.e., keys that values have a meaning to
 database end users and are used to refer to the entities outside the 
software system.</p><p><i>Seq nr:</i> 28<br><i>Query:</i> <b>Surrogate key columns</b><br><i>General goal:</i>
 Find surrogate keys. Surrogate key is a key that consist of one column.
 The key has been declared by using PRIMARY KEY or UNIQUE constraint. 
The column is associated with a sequence generator (either external or 
internal, i.e., created by the system automatically because the column 
has been declared as an identity column). The column does not 
participate in any foreign key.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://en.wikipedia.org/wiki/Surrogate_key">https://en.wikipedia.org/wiki/Surrogate_key</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_id</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">id</td></tr></tbody></table></p><p>Query result generated in 0.0148 seconds.</p><p><i>Seq nr:</i> 29<br><i>Query:</i> <b>Referential degree of tables</b><br><i>General goal:</i> This metric represents the number of foreign keys in a base table.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li>Piattini, M., Calero, C., Sahraoui, H. A., &amp; Lounis, H. (2001). Object-relational database metrics. L'Objet, 7(4), 477-496.</li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">number_of_foreign_keys</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">1</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">0</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0031 seconds.</p><p><i>Seq nr:</i> 30<br><i>Query:</i> <b>All foreign key constraints</b><br><i>General goal:</i> Enforce referential integrity in database. Find all referential integrity (foreign key) constraints.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">conname</th><th class="tv_small">foreign_schema</th><th class="tv_small">foreign_table</th><th class="tv_small">foreign_col</th><th class="tv_small">target_schema</th><th class="tv_small">target_table</th><th class="tv_small">target_col</th><th class="tv_small">on_update</th><th class="tv_small">on_delete</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">FK_person person_state_type</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">{person_state_type_code}</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">{persons_state_type_code}</td><td class="table_results">NO ACTION</td><td class="table_results">CASCADE</td></tr></tbody></table></p><p>Query result generated in 0.0032 seconds.</p><p><i>Seq nr:</i> 31<br><i>Query:</i> <b>Find all non-foreign key columns of base tables</b><br><i>General goal:</i> Find all non-foreign key columns of base tables. Make sure that no foreign key constraint is missing.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">person_id</td><td class="table_results">integer</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_text</td><td class="table_results">text</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_registration_time</td><td class="table_results">timestamp without time zone</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">check_date</td><td class="table_results">timestamp without time zone</td></tr><tr class="tv1"><td class="table_results">5</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">active</td><td class="table_results">boolean</td></tr><tr class="tv2"><td class="table_results">6</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_id</td><td class="table_results">integer</td></tr><tr class="tv1"><td class="table_results">7</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">person_state_type_code</td><td class="table_results">integer</td></tr><tr class="tv2"><td class="table_results">8</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">name</td><td class="table_results">character varying</td></tr><tr class="tv1"><td class="table_results">9</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">id</td><td class="table_results">integer</td></tr><tr class="tv2"><td class="table_results">10</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">first_name</td><td class="table_results">character varying</td></tr><tr class="tv1"><td class="table_results">11</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">last_name</td><td class="table_results">character varying</td></tr><tr class="tv2"><td class="table_results">12</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">registration_time</td><td class="table_results">timestamp with time zone</td></tr></tbody></table></p><p>Query result generated in 0.0123 seconds.</p><p><i>Seq nr:</i> 32<br><i>Query:</i> <b>Non-foreign key columns that have no associated CHECK constraints</b><br><i>General goal:</i>
 Find what are the base table columns that are not foreign key columns 
and that have no associated CHECK constraints? Perhaps some CHECK 
constraints are missing.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">7</font></b> rows!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th><th class="tv">character_maximum_length</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">person_id</td><td class="table_results">integer</td><td class="table_results">&nbsp;</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_registration_time</td><td class="table_results">timestamp without time zone</td><td class="table_results">&nbsp;</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">active</td><td class="table_results">boolean</td><td class="table_results">&nbsp;</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_id</td><td class="table_results">integer</td><td class="table_results">&nbsp;</td></tr><tr class="tv1"><td class="table_results">5</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">id</td><td class="table_results">integer</td><td class="table_results">&nbsp;</td></tr><tr class="tv2"><td class="table_results">6</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">first_name</td><td class="table_results">character varying</td><td class="table_results">50</td></tr><tr class="tv1"><td class="table_results">7</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">registration_time</td><td class="table_results">timestamp with time zone</td><td class="table_results">&nbsp;</td></tr></tbody></table></p><p>Query result generated in 0.0373 seconds.</p><p><i>Seq nr:</i> 33<br><i>Query:</i> <b>All table CHECK constraints</b><br><i>General goal:</i>
 Find all CHECK constraints (except NOT NULL) that are associated with a
 base table or a foreign table column. It is useful to enforce as many 
constraints at database level as possible. In this way one improves data
 quality as well as gives extra information to the database users 
(including the DBMS engines, development environments, applications).<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="http://nathanmlong.com/2016/01/protect-your-data-with-postgresql-constraints/">http://nathanmlong.com/2016/01/protect-your-data-with-postgresql-constraints/</a></li><li><a target="_blank" href="https://kevin.burke.dev/kevin/faster-correct-database-queries/">https://kevin.burke.dev/kevin/faster-correct-database-queries/</a></li><li><a target="_blank" href="http://www.thatjeffsmith.com/archive/2011/06/response-normalization-myths-that-really-make-me-crazy/">http://www.thatjeffsmith.com/archive/2011/06/response-normalization-myths-that-really-make-me-crazy/</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">table_type</th><th class="tv_small">column_name</th><th class="tv_small">check_clause</th><th class="tv_small">constraint_name</th><th class="tv_small">check_type</th><th class="tv_small">domain_schema</th><th class="tv_small">domain_name</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">check_date</td><td class="table_results">(((comment_text !~ '^[[:space:]]*$'::text) AND (check_date &gt;= CURRENT_TIMESTAMP)))</td><td class="table_results">comment_check</td><td class="table_results">TABLE CHECK</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr><tr class="tv2_small"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">comment_text</td><td class="table_results">(((comment_text !~ '^[[:space:]]*$'::text) AND (check_date &gt;= CURRENT_TIMESTAMP)))</td><td class="table_results">comment_check</td><td class="table_results">TABLE CHECK</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr><tr class="tv1_small"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">BASE TABLE</td><td class="table_results">name</td><td class="table_results">((btrim((name)::text) &lt;&gt; ''::text))</td><td class="table_results">chk_person_state_type_name</td><td class="table_results">TABLE CHECK</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr><tr class="tv2_small"><td class="table_results">4</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">BASE TABLE</td><td class="table_results">person_state_type_code</td><td class="table_results">((person_state_type_code &gt; 0))</td><td class="table_results">chk_code</td><td class="table_results">TABLE CHECK</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr><tr class="tv1_small"><td class="table_results">5</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">BASE TABLE</td><td class="table_results">person_state_type_code</td><td class="table_results">((persons_state_type_code &gt; 0))</td><td class="table_results">chk_code</td><td class="table_results">TABLE CHECK</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr><tr class="tv2_small"><td class="table_results">6</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">last_name</td><td class="table_results">(((last_name)::text !~ '[[:digit:]]'::text))</td><td class="table_results">chk_person_data_last_name2</td><td class="table_results">TABLE CHECK</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr><tr class="tv1_small"><td class="table_results">7</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">last_name</td><td class="table_results">((btrim((last_name)::text) IS NOT NULL))</td><td class="table_results">chk_person_data_last_name</td><td class="table_results">TABLE CHECK</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr><tr class="tv2_small"><td class="table_results">8</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">persons_state_type_code</td><td class="table_results">((person_state_type_code &gt; 0))</td><td class="table_results">chk_code</td><td class="table_results">TABLE CHECK</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr><tr class="tv1_small"><td class="table_results">9</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">persons_state_type_code</td><td class="table_results">((persons_state_type_code &gt; 0))</td><td class="table_results">chk_code</td><td class="table_results">TABLE CHECK</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr></tbody></table></p><p>Query result generated in 0.0124 seconds.</p><p><i>Seq nr:</i> 34<br><i>Query:</i> <b>The number and percentage of base tables without CHECK constraints</b><br><i>General goal:</i>
 Find the extent in which data integrity is checked at the database 
level. Find the number and percentage of base tables that do not have 
any associated CHECK constraints.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">number_of_base_tables_with_checks</th><th class="tv">number_of_base_tables</th><th class="tv">percentage_of_base_tables_without_checks</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">3</td><td class="table_results">3</td><td class="table_results">0.0</td></tr></tbody></table></p><p>Query result generated in 0.0137 seconds.</p><p><i>Seq nr:</i> 35<br><i>Query:</i> <b>CHECK constraints that involve more than one column</b><br><i>General goal:</i>
 Find multicolumn CHECK constraints. Such constraints must be associated
 directly with a base table, i.e., these cannot be associated with a 
domain. Enforce as much data integrity as possible at the database level
 and prefer declarative constraints to a trigger.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">conname</th><th class="tv">schema</th><th class="tv">table</th><th class="tv">columns</th><th class="tv">number_of_columns</th><th class="tv">consrc</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">comment_check</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment.comment_text,<br>comment.check_date</td><td class="table_results">2</td><td class="table_results">(((comment_text !~ '^[[:space:]]*$'::text) AND (check_date &gt;= CURRENT_TIMESTAMP)))</td></tr></tbody></table></p><p>Query result generated in 0.0019 seconds.</p><p><i>Seq nr:</i> 36<br><i>Query:</i> <b>Patterns of the Boolean expressions of simple CHECK constraints</b><br><i>General goal:</i>
 Find patterns of the Boolean expressions of simple CHECK constraints 
(involve only one column). Do not solve the same task in different 
places differently. The same rule could be implemented with CHECK 
constraints that have different Boolean expressions. "If you do 
something a certain way, do all similar things in the same way." (Robert
 C. Martin, Clean Code)<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li>The corresponding code smell in case of cleaning code is "G11: Inconsistency". (Robert C. Martin, Clean Code)</li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">pattern</th><th class="tv">number_of_occurrences</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">((VALUE &gt; 0))</td><td class="table_results">2</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">(((VALUE)::text !~ '[[:digit:]]'::text))</td><td class="table_results">1</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">((btrim((VALUE)::text) &lt;&gt; ''::text))</td><td class="table_results">1</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">((btrim((VALUE)::text) IS NOT NULL))</td><td class="table_results">1</td></tr></tbody></table></p><p>Query result generated in 0.013 seconds.</p><p><i>Seq nr:</i> 37<br><i>Query:</i> <b>CHECK constraints on columns with temporal data</b><br><i>General goal:</i>
 If your table contains columns with temporal data, then it will be 
appropriate to restrict the range of possible values in these columns 
because some of the values that belong to the type might not be 
appropriate (for instance, imagine a client who was born in 1100-12-03 
or a contract that was registered in 3890-12-12- 12:45). If your table 
contains multiple columns with temporal data that denote events, then 
the rule about the order of the events must be enforced, if possible.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">table_type</th><th class="tv_small">column_name</th><th class="tv_small">data_type</th><th class="tv_small">check_clause</th><th class="tv_small">check_type</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">check_date</td><td class="table_results">timestamp without time zone</td><td class="table_results">(((comment_text !~ '^[[:space:]]*$'::text) AND (check_date &gt;= CURRENT_TIMESTAMP)))</td><td class="table_results">TABLE CHECK</td></tr><tr class="tv2_small"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">comment_registration_time</td><td class="table_results">timestamp without time zone</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr><tr class="tv1_small"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">registration_time</td><td class="table_results">timestamp with time zone</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr></tbody></table></p><p>Query result generated in 0.0327 seconds.</p><p><i>Seq nr:</i> 38<br><i>Query:</i> <b>CHECK constraints on columns with personal names</b><br><i>General goal:</i>
 Find CHECK constraints on base table or foreign table columns that 
contain data about personal names. Make sure that the constraints do not
 restrict registration of legal names.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/">https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/</a></li><li><a target="_blank" href="https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/">https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">table_type</th><th class="tv_small">column_name</th><th class="tv_small">check_clause</th><th class="tv_small">constraint_name</th><th class="tv_small">check_type</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">last_name</td><td class="table_results">(((last_name)::text !~ '[[:digit:]]'::text))</td><td class="table_results">chk_person_data_last_name2</td><td class="table_results">TABLE CHECK</td></tr><tr class="tv2_small"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">last_name</td><td class="table_results">((btrim((last_name)::text) IS NOT NULL))</td><td class="table_results">chk_person_data_last_name</td><td class="table_results">TABLE CHECK</td></tr></tbody></table></p><p>Query result generated in 0.0209 seconds.</p><p><i>Fixing suggestion:</i> Drop the too restrictive constraints.</p><p><i>Seq nr:</i> 39<br><i>Query:</i> <b>CHECK constraints that use non-deterministic functions</b><br><i>General goal:</i>
 Discover incorrect usage of non-deterministic functions in CHECK 
constraints. Find base table columns and foreign table columns that have
 a CHECK constraint that refers to a non-deterministic function 
(current_date, current_timestamp, localtimestamp).<br><i>Goal in the test:</i> <b>If exists, then suspicious</b></p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">table_type</th><th class="tv_small">column_name</th><th class="tv_small">check_clause</th><th class="tv_small">constraint_name</th><th class="tv_small">check_type</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">check_date</td><td class="table_results">(((comment_text !~ '^[[:space:]]*$'::text) AND (check_date &gt;= CURRENT_TIMESTAMP)))</td><td class="table_results">comment_check</td><td class="table_results">TABLE CHECK</td></tr><tr class="tv2_small"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">comment_text</td><td class="table_results">(((comment_text !~ '^[[:space:]]*$'::text) AND (check_date &gt;= CURRENT_TIMESTAMP)))</td><td class="table_results">comment_check</td><td class="table_results">TABLE CHECK</td></tr></tbody></table></p><p>Query result generated in 0.0125 seconds.</p><p><i>Seq nr:</i> 40<br><i>Query:</i> <b>Percentage of optional columns</b><br><i>General goal:</i>
 What is the percentage of optional columns (that permit NULLs) in case 
of each base table? It is better to prohibit the use of NULLs in as many
 columns as possible. Otherwise the results of queries may be 
misleading.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/</a></li><li><a target="_blank" href="http://www.dbdebunk.com/2017/04/null-value-is-contradiction-in-terms.html">http://www.dbdebunk.com/2017/04/null-value-is-contradiction-in-terms.html</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">percentage_of_optional</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">50.00</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">50.00</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">0.00</td></tr></tbody></table></p><p>Query result generated in 0.0137 seconds.</p><p><i>Seq nr:</i> 41<br><i>Query:</i> <b>Optional base table columns</b><br><i>General goal:</i> Find optional base table columns, i.e., columns that permit NULLs. Are you sure you want to allow NULLs in these columns?<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="http://www.dbdebunk.com/2017/04/null-value-is-contradiction-in-terms.html">http://www.dbdebunk.com/2017/04/null-value-is-contradiction-in-terms.html</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_registration_time</td><td class="table_results">timestamp without time zone</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">check_date</td><td class="table_results">timestamp without time zone</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">active</td><td class="table_results">boolean</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">name</td><td class="table_results">character varying</td></tr></tbody></table></p><p>Query result generated in 0.0322 seconds.</p><p><i>Fixing suggestion:</i> Define NOT NULL constraints to the columns, if necessary.</p><p><i>Seq nr:</i> 42<br><i>Query:</i> <b>Optional columns before mandatory columns</b><br><i>General goal:</i> Place mandatory columns before optional columns<br><i>Goal in the test:</i> <b>If
 exists, then suspicious. M denotes a mandatory column and O an optional
 column. Columns are sorted based on the ordinal position.</b><br><i>Reliability of the results:</i> Low (Many false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">pattern</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">MMOOOM</td></tr></tbody></table></p><p>Query result generated in 0.0125 seconds.</p><p><i>Seq nr:</i> 43<br><i>Query:</i> <b>All column DEFAULT values</b><br><i>General goal:</i> Fidnd all the default values of base table, view, and foreign table columns.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_type</th><th class="tv_small">table_name</th><th class="tv_small">column_name</th><th class="tv_small">data_type</th><th class="tv_small">domain_schema</th><th class="tv_small">domain_name</th><th class="tv_small">default_value</th><th class="tv_small">default_type</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">BASE TABLE</td><td class="table_results">comment</td><td class="table_results">comment_registration_time</td><td class="table_results">timestamp without time zone</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td><td class="table_results">CURRENT_TIMESTAMP</td><td class="table_results">Column default</td></tr><tr class="tv2_small"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">BASE TABLE</td><td class="table_results">comment</td><td class="table_results">comment_id</td><td class="table_results">integer</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td><td class="table_results">nextval('comment_comment_id_seq'::regclass)</td><td class="table_results">Column default</td></tr></tbody></table></p><p>Query result generated in 0.0105 seconds.</p><p><i>Seq nr:</i> 44<br><i>Query:</i> <b>Potentially missing default values of base table columns</b><br><i>General goal:</i>
 Find columns of base tables that contain Boolean or temporal values and
 do not have a default value. These columns could/should often have 
default value.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Low (Many false-positive results)<br>The query found <b><font color="red">3</font></b> rows!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">active</td><td class="table_results">boolean</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">check_date</td><td class="table_results">timestamp without time zone</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">registration_time</td><td class="table_results">timestamp with time zone</td></tr></tbody></table></p><p>Query result generated in 0.1054 seconds.</p><p><i>Seq nr:</i> 45<br><i>Query:</i> <b>The number of sequence generators in different schemas</b><br><i>General goal:</i>
 Identify the number of sequence generators in different schemas. 
Surrogate key values must be generated by using the system (the sequence
 generator mechanism in case of PostgreSQL). If there are no sequence 
generators, then there is a question as to whether there are no 
surrogate keys in the database at all (could be possible and OK) or 
(more probable) developers have forgotten to implement the generation of
 surrogate keys at the database level. An alternative is to implement 
generation of unique values at the application level or at the database 
level by using triggers. However, such implementation would most 
probably lead to the performance penalty because adding new rows to the 
table must be serialized, i.e., it can be done in one session at a time.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">schema_name</th><th class="tv">number_of_external_sequences</th><th class="tv">number_of_internal_sequences</th><th class="tv">total_number_of_sequences</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">1</td><td class="table_results">1</td><td class="table_results">2</td></tr></tbody></table></p><p>Query result generated in 0.0072 seconds.</p><p><i>Seq nr:</i> 46<br><i>Query:</i> <b>Table columns that are associated with a sequence generator</b><br><i>General goal:</i>
 Surrogate key values must be generated by using the system (the 
sequence generator mechanism in case of PostgreSQL). If there is no 
usage of sequence generators, then there is a question as to whether 
there are no surrogate keys in the database at all (could be possible 
and OK) or (more probable) developers have forgotten to implement the 
generation of surrogate keys.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_type</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th><th class="tv">sequence_generator_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">BASE TABLE</td><td class="table_results">comment</td><td class="table_results">comment_id</td><td class="table_results">integer</td><td class="table_results">EXTERNAL</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">BASE TABLE</td><td class="table_results">public_person_data</td><td class="table_results">id</td><td class="table_results">integer</td><td class="table_results">INTERNAL</td></tr></tbody></table></p><p>Query result generated in 0.0166 seconds.</p><p><i>Seq nr:</i> 47<br><i>Query:</i> <b>Base tables where certainly registration time is not recorded</b><br><i>General goal:</i>
 Find base tables that do not have any column with a timestamp type. In 
such tables certainly registration time is not recorded. Make sure as to
 whether recording registration time is necessary.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reliability of the results:</i> Low (Many false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">person_state_type</td></tr></tbody></table></p><p>Query result generated in 0.0069 seconds.</p><p><i>Seq nr:</i> 48<br><i>Query:</i> <b>Overview of data type usage in the base table columns</b><br><i>General goal:</i>
 Get overview of used data types in the columns of base tables. If the 
selection is very small then this is a warning sign that perhaps 
unsuitable types have been used.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://www.postgresql.org/docs/current/datatype.html">https://www.postgresql.org/docs/current/datatype.html</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">data_type</th><th class="tv">number_of_usages</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">integer</td><td class="table_results">4</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">character varying</td><td class="table_results">3</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">timestamp without time zone</td><td class="table_results">2</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">boolean</td><td class="table_results">1</td></tr><tr class="tv1"><td class="table_results">5</td><td class="table_results">smallint</td><td class="table_results">1</td></tr><tr class="tv2"><td class="table_results">6</td><td class="table_results">text</td><td class="table_results">1</td></tr><tr class="tv1"><td class="table_results">7</td><td class="table_results">timestamp with time zone</td><td class="table_results">1</td></tr></tbody></table></p><p>Query result generated in 0.0067 seconds.</p><p><i>Seq nr:</i> 49<br><i>Query:</i> <b>Base table columns with SMALLINT or BOOLEAN type</b><br><i>General goal:</i>
 Each column should have the most appropriate data type. Developers 
sometimes forget to use SMALLINT type even if it is logically the best 
choice. Developers also sometimes forget to use BOOLEAN type and instead
 invent something.<br><i>Goal in the test:</i> <b>If there is too few of them, then it is suspicious</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">active</td><td class="table_results">boolean</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">persons_state_type_code</td><td class="table_results">smallint</td></tr></tbody></table></p><p>Query result generated in 0.0073 seconds.</p><p><i>Seq nr:</i> 50<br><i>Query:</i> <b>Base table columns with the following types: BIGINT, INTEGER, TEXT, VARCHAR without max character length</b><br><i>General goal:</i>
 Each column should have the most appropriate data type. Developers 
sometimes misuse BIGINT, INTEGER, TEXT or VARCHAR type in places where a
 type that permits smaller values would be more appropriate and 
semantically descriptive.<br><i>Goal in the test:</i> <b>If there is too many of them, then it is suspicious</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://stackoverflow.com/questions/29560016/how-to-add-a-length-constraint-to-a-text-field">https://stackoverflow.com/questions/29560016/how-to-add-a-length-constraint-to-a-text-field</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">person_id</td><td class="table_results">integer</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_id</td><td class="table_results">integer</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">person_state_type_code</td><td class="table_results">integer</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">id</td><td class="table_results">integer</td></tr><tr class="tv1"><td class="table_results">5</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_text</td><td class="table_results">text</td></tr></tbody></table></p><p>Query result generated in 0.0114 seconds.</p><p><i>Fixing suggestion:</i>
 Change the data type or field size. If the type was selected with a 
perspective that values in the column will become quite big over time, 
then consider adding a CHECK constraint that further limits the values 
in the column.</p><p><i>Seq nr:</i> 51<br><i>Query:</i> <b>Base table columns with CHAR(n) or VARCHAR(n) type</b><br><i>General goal:</i>
 Find base table columns with CHAR(n) or VARCHAR(n) type and make sure 
that n is not too big or too small. Also make sure that you do not use 
CHAR(n) in case of columns that have to keep variable length strings. 
"Values of type character are physically padded with spaces to the 
specified width n, and are stored and displayed that way" (<a target="_blank" href="https://www.postgresql.org/docs/current/datatype-character.html">https://www.postgresql.org/docs/current/datatype-character.html</a>)<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th><th class="tv">character_maximum_length</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">name</td><td class="table_results">character varying</td><td class="table_results">50</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">first_name</td><td class="table_results">character varying</td><td class="table_results">50</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">last_name</td><td class="table_results">character varying</td><td class="table_results">50</td></tr></tbody></table></p><p>Query result generated in 0.0115 seconds.</p><p><i>Fixing suggestion:</i>
 Change the field size. If the column is specified through a domain, 
then you have to create a new domain and associate the column with the 
new domain because you cannot change the field size with the ALTER 
DOMAIN statement.</p><p><i>Seq nr:</i> 52<br><i>Query:</i> <b>Foreign keys with ON DELETE CASCADE</b><br><i>General goal:</i>
 Referential constraints (foreign key constraints) that employ ON DELETE
 CASCADE compensatory action. ON DELETE CASCADE should only be used if 
it has been created based on a generalization or a composition in the 
conceptual data model or if the foreign key connects a table that 
corresponds to the main entity type with a table that corresponds to a 
non-main entity type.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">conname</th><th class="tv_small">foreign_schema</th><th class="tv_small">foreign_table</th><th class="tv_small">foreign_col</th><th class="tv_small">target_schema</th><th class="tv_small">target_table</th><th class="tv_small">target_col</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">FK_person person_state_type</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">{person_state_type_code}</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">{persons_state_type_code}</td></tr></tbody></table></p><p>Query result generated in 0.0031 seconds.</p><p><i>Seq nr:</i> 53<br><i>Query:</i> <b>The number of domains by schema and in total</b><br><i>General goal:</i> Identify the number of domains in different schemas.<br><i>Goal in the test:</i> <b>Requirement is to have at least one domain</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">domain_schema</th><th class="tv">number_of_domains</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">&nbsp;</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0014 seconds.</p><p><i>Seq nr:</i> 54<br><i>Query:</i> <b>Coverage by derived tables</b><br><i>General goal:</i>
 Find for each base table the list of derived tables (both "ordinary" 
and materialized views) that refer to the base table. If the database is
 used through the public database interface (virtual data layer), then, 
ideally, each table is used by at least one view.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">list_of_derived_tables</th><th class="tv">number_of_views</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">&nbsp;</td><td class="table_results">0</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">&nbsp;</td><td class="table_results">0</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">&nbsp;</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0077 seconds.</p><p><i>Seq nr:</i> 55<br><i>Query:</i> <b>The total number of physical lines of code in the bodies of user-defined SQL and PL/pgSQL functions/procedures</b><br><i>General goal:</i>
 Find a numerical measure that describes the extent of the database 
public interface (virtual data layer) through which users access the 
database.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://en.wikipedia.org/wiki/Source_lines_of_code">https://en.wikipedia.org/wiki/Source_lines_of_code</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">number_of_physical_lines_of_code</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0024 seconds.</p><p><i>Seq nr:</i> 56<br><i>Query:</i> <b>Check as to whether password is hashed</b><br><i>General goal:</i>
 Password should not be open text. Find columns of base tables that 
based on the name of the column probably contain passwords and return a 
value from each such column.<br><i>Goal in the test:</i> <b>Overview. Password must be hashed. See exercise 10 for details.</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">sample_values</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">&nbsp;</td></tr></tbody></table></p><p>Query result generated in 0.0154 seconds.</p><p><i>Seq nr:</i> 57<br><i>Query:</i> <b>Grantees</b><br><i>General goal:</i>
 Database must be used by users who have minimal set of privileges for 
performing tasks. The query helps to find out as to whether some 
user/role other than PUBLIC and a superuser have rights to use tables 
and routines of the database.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">grantee</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">erki</td></tr></tbody></table></p><p>Query result generated in 0.0207 seconds.</p><p><i>Seq nr:</i> 58<br><i>Query:</i> <b>Table privileges</b><br><i>General goal:</i> Check as to whether there are no unnecessary privileges.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">grantee</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">table_type</th><th class="tv">privileges</th><th class="tv">number_of_privileges</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">erki</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">{INSERT,SELECT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER}</td><td class="table_results">7</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">erki</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">BASE TABLE</td><td class="table_results">{INSERT,SELECT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER}</td><td class="table_results">7</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">erki</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">{INSERT,SELECT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER}</td><td class="table_results">7</td></tr></tbody></table></p><p>Query result generated in 0.0051 seconds.</p><p><i>Seq nr:</i> 59<br><i>Query:</i> <b>Base tables with the biggest number of rows</b><br><i>General goal:</i> There should be test data in the tables.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">schema_name</th><th class="tv">table_name</th><th class="tv">reltuples</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">0</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">0</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.1131 seconds.</p><p><i>Seq nr:</i> 60<br><i>Query:</i> <b>Perhaps a state machine is implemented with temporal columns</b><br><i>General goal:</i> Find implementations of state machines that uses a set of Boolean columns.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li>L.
 Silverston ja P. Agnew, The Data Model Resource Book, Volume 3: 
Universal Patterns for Data Modeling, Chichester, John Wiley &amp; Sons
 Ltd, 2009. Level 1 Status Pattern</li><li><a target="_blank" href="https://dba.stackexchange.com/questions/206447/how-to-design-databse-for-storing-object-states-in-mysql">https://dba.stackexchange.com/questions/206447/how-to-design-databse-for-storing-object-states-in-mysql</a></li><li><a target="_blank" href="https://digikogu.taltech.ee/et/Item/101f40e2-d9fe-4bef-ab25-54508f18c078">Representing the Status of the Main Entities of an Information System in SQL Databases</a> Master Thesis, in Estonian.</li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">timestamp_columns</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_registration_time timestamp without time zone;<br>check_date timestamp without time zone</td></tr></tbody></table></p><p>Query result generated in 0.0062 seconds.</p><p><i>Fixing suggestion:</i>
 Use instread state classifier. See Level 2 Status Pattern, Current 
Status from L. Silverston ja P. Agnew, The Data Model Resource Book, 
Volume 3: Universal Patterns for Data Modeling, Chichester, John Wiley 
&amp; Sons Ltd, 2009.</p><p><i>Seq nr:</i> 61<br><i>Query:</i> <b>The storage size of each table (including indexes) (the system catalog excluded)</b><br><i>General goal:</i> Get overview of disk usage.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://wiki.postgresql.org/wiki/Disk_Usage">https://wiki.postgresql.org/wiki/Disk_Usage</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">schema</th><th class="tv">object_name</th><th class="tv">object_type</th><th class="tv">table_size</th><th class="tv">indexes_size</th><th class="tv">total_size</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">0 bytes</td><td class="table_results">8192 bytes</td><td class="table_results">16 kB</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">BASE TABLE</td><td class="table_results">0 bytes</td><td class="table_results">8192 bytes</td><td class="table_results">8192 bytes</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">0 bytes</td><td class="table_results">8192 bytes</td><td class="table_results">8192 bytes</td></tr></tbody></table></p><p>Query result generated in 0.0013 seconds.</p><p><i>Seq nr:</i> 62<br><i>Query:</i> <b>The storage size of each index (the system catalog excluded)</b><br><i>General goal:</i> Get overview of disk usage.<br><i>Goal in the test:</i> <b>Overview</b><br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://wiki.postgresql.org/wiki/Disk_Usage">https://wiki.postgresql.org/wiki/Disk_Usage</a></li></ul><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">schema</th><th class="tv">object_name</th><th class="tv">object_type</th><th class="tv">total_size</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment_pkey</td><td class="table_results">INDEX</td><td class="table_results">8192 bytes</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">person_state_type_pkey</td><td class="table_results">INDEX</td><td class="table_results">8192 bytes</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">pk_person</td><td class="table_results">INDEX</td><td class="table_results">8192 bytes</td></tr></tbody></table></p><p>Query result generated in 0.0007 seconds.</p><p><i>Seq nr:</i> 63<br><i>Query:</i> <b>The total storage size of the database (the system catalog included)</b><br><i>General goal:</i> Get overview of disk usage.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">database_total_size</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">8905 kB</td></tr></tbody></table></p><p>Query result generated in 0.0025 seconds.</p><p><i>Seq nr:</i> 64<br><i>Query:</i> <b>The total storage size of all indexes (the system catalog excluded)</b><br><i>General goal:</i> Get overview of disk usage.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">total_size</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">24 kB</td></tr></tbody></table></p><p>Query result generated in 0.0011 seconds.</p><p><i>Seq nr:</i> 65<br><i>Query:</i> <b>Percentage of the total index storage size from the total database storage size (system catalog included)</b><br><i>General goal:</i> Get overview of disk usage.<br><i>Goal in the test:</i> <b>Overview</b></p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">database_total_size</th><th class="tv">index_total_size</th><th class="tv">percentage_of_index_size_from_total_size</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">8905 kB</td><td class="table_results">5960 kB</td><td class="table_results">66.9</td></tr></tbody></table></p><p>Query result generated in 0.0079 seconds.</p><p>Page generated in 2.2341 seconds.</p><p><a href="#top">Top</a></p></div>


</body></html>