<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="find_problems_automatically_files/queries.css">
<div class="medium_line_spacing">
<title>System of queries</title>
<p>Test that contains queries in case of which each returned row means quite certainly a problem.</p><p></p><p>The test contains <b><big><font color="red">344</font></big></b> queries.</p><p><i>Seq nr:</i> 1<br><i>Query:</i> <b>Insufficient number of user-defined base tables</b><br><i>General goal:</i> There must be at least seven user-defined base tables in the database.<br><i>Goal in the test:</i> <b>The result should be empty.  If it is not, then complete exercises 2-4.</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">comment</th><th class="tv">the_number_of_tables</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">Too few base tables, must be at least 7</td><td class="table_results">3</td></tr></tbody></table></p><p>Query result generated in 0.0102 seconds.</p><p><i>Seq nr:</i> 2<br><i>Query:</i> <b>Insufficient number of user-defined views</b><br><i>General goal:</i> There must be at least three user-defined views in the database.<br><i>Goal in the test:</i> <b>The result should be empty. If it is not, then complete exercise 7.</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">comment</th><th class="tv">number_of_views</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">Too few views, must be at least 3</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0013 seconds.</p><p><i>Fixing suggestion:</i> Create additional views.</p><p><i>Seq nr:</i> 3<br><i>Query:</i> <b>Insufficient number of user-defined domains</b><br><i>General goal:</i>
 There must be at least one user-defined domain in the database and it 
must be used in case of at least two columns of base tables.<br><i>Goal in the test:</i> <b>The result should be empty.  If it is not, then complete exercise 6.</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">comment</th><th class="tv">number_of_domains</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">Too few domains, must be at least one</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0151 seconds.</p><p><i>Fixing suggestion:</i> Create additional domains and use these to define columns of base tables.</p><p><i>Seq nr:</i> 4<br><i>Query:</i> <b>Insufficient number of user-defined non-trigger routines</b><br><i>General goal:</i> There must be at least three user-defined non-trigger routines in the database.<br><i>Goal in the test:</i> <b>The result should be empty.  If it is not, then complete exercise 8.</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">comment</th><th class="tv">number_of_routines</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">Too few user-defined routines, must be at least 3</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0059 seconds.</p><p><i>Fixing suggestion:</i> Create additional routines.</p><p><i>Seq nr:</i> 5<br><i>Query:</i> <b>Insufficient number of user-defined triggers+rules</b><br><i>General goal:</i> There must be at least two user-defined triggers and/or rules in the database.<br><i>Goal in the test:</i> <b>The result should be empty.  If it is not, then complete exercise 11.</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">comment</th><th class="tv">the_number_of_triggers_rules</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">Too few triggers and/or rules, must be at least 2</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0032 seconds.</p><p><i>Fixing suggestion:</i> Create additional triggers or rules.</p><p><i>Seq nr:</i> 6<br><i>Query:</i> <b>Insufficient number of user-defined foreign tables</b><br><i>General goal:</i> There must be at least one user-defined foreign table in the database (two, if you make the project based on the workbook).<br><i>Goal in the test:</i> <b>The result should be empty. If it is not, then complete exercise 5.</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">comment</th><th class="tv">number_of_foreign_tables</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">Too few foreign tables, must be at least 1 (2 if you make your project based on the workbook)</td><td class="table_results">0</td></tr></tbody></table></p><p>Query result generated in 0.0036 seconds.</p><p><i>Seq nr:</i> 7<br><i>Query:</i> <b>Too short names of database objects</b><br><i>General goal:</i>
 "Names in software are 90 percent of what make software readable. You 
need to take the time to choose them wisely and keep them relevant. 
Names are too important to treat carelessly. Names should not cause 
confusion." (Robert C. Martin, Clean Code) The names should be 
meaningful and searchable. Find the names (identifiers) of user-defined 
database objects that are shorter than three characters.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li>The
 corresponding code smells in case of cleaning code are "N1: Choose 
Descriptive Names", "N4: Unambiguous Names", "N5: Use Long Names for 
Long Scopes", "N7: Names Should Describe Side-Effects". (Robert C. 
Martin, Clean Code)</li><li>Smell "Meaningless name": Sharma, T., 
Fragkoulis, M., Rizou, S., Bruntink, M. and Spinellis, D.: Smelly 
relations: measuring and understanding database schema quality. In: 
Proceedings of the 40th International Conference on Software 
Engineering: Software Engineering in Practice, pp. 55-64. ACM, (2018).</li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">container_name</th><th class="tv">container_type</th><th class="tv">suspected_name</th><th class="tv">suspected_object_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public.public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">id</td><td class="table_results">COLUMN</td></tr></tbody></table></p><p>Query result generated in 0.0398 seconds.</p><p><i>Fixing suggestion:</i> Rename object and give these meaningful names. Follow a naming convention.</p><p><i>Seq nr:</i> 8<br><i>Query:</i> <b>Too short table constraint names</b><br><i>General goal:</i>
 The names should be expressive. Find names of constraints, which are 
associated directly to a table, that are shorter than the length of the 
name of the table + two characters.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li>The corresponding code smell in case of cleaning code is "N1: Choose Descriptive Names". (Robert C. Martin, Clean Code)</li><li>Smell
 "Meaningless name": Sharma, T., Fragkoulis, M., Rizou, S., Bruntink, M.
 and Spinellis, D.: Smelly relations: measuring and understanding 
database schema quality. In: Proceedings of the 40th International 
Conference on Software Engineering: Software Engineering in Practice, 
pp. 55-64. ACM, (2018).</li></ul><br>The query found <b><font color="red">3</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">constraint_name</th><th class="tv">constraint_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">chk_code</td><td class="table_results">TABLE CHECK</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">chk_code</td><td class="table_results">TABLE CHECK</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">pk_person</td><td class="table_results">PRIMARY KEY</td></tr></tbody></table></p><p>Query result generated in 0.0009 seconds.</p><p><i>Fixing suggestion:</i> Rename the constraint. Follow a naming convention.</p><p><i>Seq nr:</i> 9<br><i>Query:</i> <b>Too generic names (tables and their columns)</b><br><i>General goal:</i>
 Find the names of tables and columns that are too generic. In SQL 
databases data/information is represented as values in columns. It is 
not a good style to use generic names like table, data, information, 
column etc. in the names of tables of columns. Moreover, avoid too 
generic column names like: id, tyyp, kood, aeg, kp,type, code, time, 
date, fk, pk.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li>The
 corresponding code smells in case of cleaning code are "N1: Choose 
Descriptive Names" and "N4: Unambiguous Names". (Robert C. Martin, Clean
 Code)</li><li>The corresponding code problem in case of cleaning code is "Add Meaningful Context". (Robert C. Martin, Clean Code)</li></ul><br>The query found <b><font color="red">3</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">schema</th><th class="tv">container</th><th class="tv">suspected_object_type</th><th class="tv">suspected_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public</td><td class="table_results">BASE TABLE</td><td class="table_results">comment</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public</td><td class="table_results">BASE TABLE</td><td class="table_results">public_person_data</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE COLUMN</td><td class="table_results">id</td></tr></tbody></table></p><p>Query result generated in 0.0363 seconds.</p><p><i>Fixing suggestion:</i>
 Add meaningful context to the name. Rename the table or its column. 
Give to it more descriptive name. Follow a naming convention.</p><p><i>Seq nr:</i> 10<br><i>Query:</i> <b>Too generic names (key columns)</b><br><i>General goal:</i>
 Find key columns with the names like id, identifikaator, code, kood, 
number, etc. The names could have subscripts as the prefix or suffix. 
These are too generic names.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br><i>Reference materials:</i> </p><ul><li>The corresponding code problem in case of cleaning code is "Add Meaningful Context". (Robert C. Martin, Clean Code)</li><li>This is a part of an antipatterns from the Bill Karwin's book of SQL antipatterns. See Chapter 4: ID Required.</li><li>The
 corresponding code smells in case of cleaning code are "N1: Choose 
Descriptive Names" and "N4: Unambiguous Names". (Robert C. Martin, Clean
 Code)</li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">constraint_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">id</td><td class="table_results">PRIMARY KEY</td></tr></tbody></table></p><p>Query result generated in 0.0018 seconds.</p><p><i>Fixing suggestion:</i>
 Add meaningful context to the name. Rename the columns. For instance, 
id =&gt; person_id and code =&gt; country_code. Follow a naming 
convention. Use the snake case in names.</p><p><i>Seq nr:</i> 11<br><i>Query:</i> <b>Too generic names (table constraints)</b><br><i>General goal:</i>
 Find table constraints (constraints that are associated directly with 
the table) that have too generic names like "constraint" or the name 
contain too generic words like "data" (all constraints restrict data in 
the table), or the name is an abbreviation of the constraint type name.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br>The query found <b><font color="red">2</font></b> rows!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">table_type</th><th class="tv">suspected_constraint_type</th><th class="tv">suspected_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">TABLE CHECK</td><td class="table_results">chk_person_data_last_name</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">TABLE CHECK</td><td class="table_results">chk_person_data_last_name2</td></tr></tbody></table></p><p>Query result generated in 0.0026 seconds.</p><p><i>Fixing suggestion:</i> Rename the constraints.</p><p><i>Seq nr:</i> 12<br><i>Query:</i> <b>Names of columns that hold personal names but do not take into account cultural diversity</b><br><i>General goal:</i> Find columns of tables (base tables, views, materialized views, foreign tables) that have the name <i>first_name</i> or <i>last_name</i>.
 Such column names do not take into account that different cultures use 
different personal name components and the number of possible components
 is more than two. If in a culture, the surname is presented before the 
given name, then the column names causes confusion.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://digi.lib.ttu.ee/i/?7072">https://digi.lib.ttu.ee/i/?7072</a></li><li><a target="_blank" href="https://www.fbiic.gov/public/2008/nov/Naming_practice_guide_UK_2006.pdf">https://www.fbiic.gov/public/2008/nov/Naming_practice_guide_UK_2006.pdf</a></li><li><a target="_blank" href="https://www.w3.org/International/questions/qa-personal-names">https://www.w3.org/International/questions/qa-personal-names</a></li><li><a target="_blank" href="https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/">https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/</a></li></ul><br>The query found <b><font color="red">2</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">table_type</th><th class="tv">column_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">first_name</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">last_name</td></tr></tbody></table></p><p>Query result generated in 0.0047 seconds.</p><p><i>Fixing suggestion:</i> Instead of column name <i>first_name</i> use <i>given_name</i>. Instead of column name <i>last_name</i> use <i>surname</i>. Consider replacing the two columns with the single column <i>person_name</i>.
 In case of base tables and foreign tables it is possible to rename the 
columns. In case of derived tables one has to drop and recreate the 
tables.<br><i>A fixing action:</i> Rename the base table or foreign table column <i>first_name</i>.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.public_person_data RENAME COLUMN first_name TO given_name;</textarea><br><i>A fixing action:</i> Rename the base table or foreign table column <i>last_name</i>.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.public_person_data RENAME COLUMN last_name TO surname;</textarea></p><p><i>Seq nr:</i> 13<br><i>Query:</i> <b>Delimited identifiers</b><br><i>General goal:</i>
 Delimited identifiers (quoted identifiers) are case sensitive. 
Identifiers of database objects should be case insensitive in order to 
simplify their management.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://blog.codinghorror.com/the-case-for-case-insensitivity/">https://blog.codinghorror.com/the-case-for-case-insensitivity/</a></li><li><a target="_blank" href="https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS">https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS</a></li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">container_name</th><th class="tv">container_type</th><th class="tv">suspected_name</th><th class="tv">object_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public.public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">FK_person person_state_type</td><td class="table_results">FOREIGN KEY</td></tr></tbody></table></p><p>Query result generated in 0.0329 seconds.</p><p><i>Fixing suggestion:</i>
 Use regular identifiers (these are not between double-quotation marks) 
instead of delimited identifiers (these are between double-quotation 
marks).</p><p><i>Seq nr:</i> 14<br><i>Query:</i> <b>Names of database objects that perhaps end with a sequence number</b><br><i>General goal:</i>
 Find the names (identifiers) of user-defined database objects that end 
with one or more digit and do not have any digits before this. Names 
should be informative. Duplicates should be avoided. Digits in names are
 a possible sign of duplication of database objects or unclear names.<br><i>Goal in the test:</i> <b>If
 exists, then suspicious. Numbers in names are permitted if they explain
 the meaning of the object but not if these are sequencde numbers or 
random numbers.</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li>The
 use of digits in names is a sign of the following antipatterns from the
 Bill Karwin's book of SQL antipatterns: Multicolumn Attributes (Chapter
 8), Metadata Tribbles (Chapter 9).</li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">container_name</th><th class="tv">container_type</th><th class="tv">suspected_name</th><th class="tv">object_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public.public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">chk_person_data_last_name<b>2</b></td><td class="table_results">TABLE CHECK</td></tr></tbody></table></p><p>Query result generated in 0.0391 seconds.</p><p><i>Fixing suggestion:</i> Do not use sequence numbers in names.</p><p><i>Seq nr:</i> 15<br><i>Query:</i> <b>Constraints with the same name within the same schema and constraint type</b><br><i>General goal:</i>
 Find names of foreign key constraints that are used within the same 
schema more than once. Find names of check constraints that are used 
within the same schema more than once. Find names of constraint triggers
 that are used within the same schema more than once. Different things 
should have different names. But here different constraints have the 
same name. Also make sure that this is not a sign of duplication.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://www.postgresql.org/message-id/pan.2004.09.05.22.56.56.521040@arvin.dk">https://www.postgresql.org/message-id/pan.2004.09.05.22.56.56.521040@arvin.dk</a></li><li><a target="_blank" href="https://www.postgresql.org/message-id/3724.1094436837%40sss.pgh.pa.us">https://www.postgresql.org/message-id/3724.1094436837%40sss.pgh.pa.us</a></li><li><a target="_blank" href="https://dba.stackexchange.com/questions/152510/enforce-constraint-name-uniqueness">https://dba.stackexchange.com/questions/152510/enforce-constraint-name-uniqueness</a></li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">constraint_type</th><th class="tv">conname</th><th class="tv">number_of_occurrences</th><th class="tv">tables</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">CHECK</td><td class="table_results">chk_code</td><td class="table_results">2</td><td class="table_results">BASE TABLE.public.person_state_type;<br>BASE TABLE.public.public_person_data</td></tr></tbody></table></p><p>Query result generated in 0.001 seconds.</p><p><i>Fixing suggestion:</i>
 Give to foreign key and check constraints as well as to constraint 
triggers unique names within a schema. Use table name in the constraint 
name. Follow a naming convention.</p><p><i>Seq nr:</i> 16<br><i>Query:</i> <b>System-generated table constraint names (constraints that involve one column)</b><br><i>General goal:</i>
 Find the names of database constraints that have been system-generated.
 Additional restrictions are that the constraints must involve only one 
column and are associated directly with a table (not through a domain). 
Names should follow the same style. If there is a mix of 
system-generated and user-defined names, then the style is most probably
 different.<br><i>Goal in the test:</i> <b>There should not be any. The task in the course requires giving names by the database programmer.</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://digikogu.taltech.ee/et/item/05157bb4-763e-4a9d-bc50-2025692b8e1d">https://digikogu.taltech.ee/et/item/05157bb4-763e-4a9d-bc50-2025692b8e1d</a></li><li><a target="_blank" href="https://pgxn.org/dist/constr_name_unif">https://pgxn.org/dist/constr_name_unif</a></li><li><a target="_blank" href="https://github.com/katrinaibast/constr_name_unif">https://github.com/katrinaibast/constr_name_unif</a></li></ul><br>The query found <b><font color="red">2</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">schema_name</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">type</th><th class="tv">constraint_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_id</td><td class="table_results">PRIMARY KEY</td><td class="table_results">comment_pkey</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">person_state_type_code</td><td class="table_results">PRIMARY KEY</td><td class="table_results">person_state_type_pkey</td></tr></tbody></table></p><p>Query result generated in 0.0027 seconds.</p><p><i>Fixing suggestion:</i> 	Use consistent style of naming things. Give names to the constraints explicitly in the statements of data definition language.</p><p><i>Seq nr:</i> 17<br><i>Query:</i> <b>Mixing system- and user defined names of constraints (constraints that involve one column)</b><br><i>General goal:</i> Use the uniform style in case of naming constraints.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://martinfowler.com/bliki/TwoHardThings.html">https://martinfowler.com/bliki/TwoHardThings.html</a></li><li><a target="_blank" href="https://stackoverflow.com/questions/7662/database-table-and-column-naming-conventions">https://stackoverflow.com/questions/7662/database-table-and-column-naming-conventions</a></li><li><a target="_blank" href="https://openacs.org/doc/eng-standards-constraint-naming">https://openacs.org/doc/eng-standards-constraint-naming</a></li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">type</th><th class="tv">number_of_constraints</th><th class="tv">number_of_constraints_with_system_generated_names</th><th class="tv">number_of_constraints_with_user_defined_names</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">PRIMARY KEY</td><td class="table_results">3</td><td class="table_results">2</td><td class="table_results">1</td></tr></tbody></table></p><p>Query result generated in 0.0051 seconds.</p><p><i>Seq nr:</i> 18<br><i>Query:</i> <b>Names of constraints (directly connected to a base table) and indexes that do not contain the table name</b><br><i>General goal:</i>
 Find constraints that are perhaps badly named. Table names help us to 
ensure the uniqueness of the names within a schema and make the names 
more expressive and user-friendly.<br><i>Goal in the test:</i> <b>If exists, then suspicious. Table names help us to ensure the uniqueness of the names within a schema. <a target="_blank" href="https://maurus.ttu.ee/helpdesk.php?kysimus=678&amp;kysimuse_teema=148&amp;aine=374">Here</a> is an explanation why the names should be unigue within a schema.</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://dba.stackexchange.com/questions/152510/enforce-constraint-name-uniqueness">https://dba.stackexchange.com/questions/152510/enforce-constraint-name-uniqueness</a></li><li><a target="_blank" href="https://www.postgresql.org/message-id/3724.1094436837%40sss.pgh.pa.us">https://www.postgresql.org/message-id/3724.1094436837%40sss.pgh.pa.us</a></li></ul><br>The query found <b><font color="red">7</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">type</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">constraint_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">TABLE CHECK</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">chk_code</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">FOREIGN KEY</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">FK_person person_state_type</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">INDEX</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">pk_person</td></tr><tr class="tv2"><td class="table_results">4</td><td class="table_results">PRIMARY KEY</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">pk_person</td></tr><tr class="tv1"><td class="table_results">5</td><td class="table_results">TABLE CHECK</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">chk_person_data_last_name2</td></tr><tr class="tv2"><td class="table_results">6</td><td class="table_results">TABLE CHECK</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">chk_code</td></tr><tr class="tv1"><td class="table_results">7</td><td class="table_results">TABLE CHECK</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">chk_person_data_last_name</td></tr></tbody></table></p><p>Query result generated in 0.003 seconds.</p><p><i>Fixing suggestion:</i>
 Use the table name in the constraint names and index names. A problem 
is that by default a PostgreSQL identifier may be at most 63 bytes long.
 Thus, in case of long table names one may have to shorten the name in 
the constraint or index names. It is important to do this consistently. 
Do not shorten the table name.</p><p><i>Seq nr:</i> 19<br><i>Query:</i> <b>Gratuitous context in case of schema objects</b><br><i>General goal:</i>
 Find schema objects that name starts with the schema name and then has 
at least one more symbol. "Shorter names are generally better than 
longer ones, so long as they are clear. Add no more context to a name 
than is necessary" (Robert C. Martin, Clean Code) Shema is a namespace. 
There cannot be in the same schema two schema objects that belong to the
 same name class and have the same name.<br><i>Goal in the test:</i> <b>If exists, then very suspicious</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br><i>Reference materials:</i> </p><ul><li>The corresponding code problem in case of cleaning code is "Don’t Add Gratuitous Context". (Robert C. Martin, Clean Code)</li></ul><br>The query found <b><font color="red">2</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">schema_name</th><th class="tv">suspected_name</th><th class="tv">object_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data_id_seq</td><td class="table_results">SEQUENCE GENERATOR</td></tr></tbody></table></p><p>Query result generated in 0.0049 seconds.</p><p><i>Fixing suggestion:</i> Rename the schema object. Remove reference to the schema from the name. Use a consistent style of naming.</p><p><i>Seq nr:</i> 20<br><i>Query:</i> <b>Gratuitous context in case of non-foreign key and non-candidate key columns</b><br><i>General goal:</i>
 Find the names on base table columns that are not a part of a candidate
 key and a foreign key and that contain the name of the table. Exclude 
very general column names (for instance, nimi, nimetus, kommentaar, 
kirjeldus, name, comment, description). In case of these using the table
 name in the column name is not a problem because it simplifies writing 
the queries based on the tables. In this case one does not have to 
rename the columns in the query result.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li>The corresponding code problem in case of cleaning code is "Don’t Add Gratuitous Context". (Robert C. Martin, Clean Code)</li></ul><br>The query found <b><font color="red">2</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results"><b>comment</b>_registration_time</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results"><b>comment</b>_text</td></tr></tbody></table></p><p>Query result generated in 0.0147 seconds.</p><p><i>Fixing suggestion:</i> Rename the columns. For instance, instead of having column <i>person_surname</i> in the table <i>Person</i> use the name <i>surname</i>. Use a consistent style of naming.</p><p><i>Seq nr:</i> 21<br><i>Query:</i> <b>Base table columns with BOOLEAN type that do not have a good name</b><br><i>General goal:</i>
 The prefic of the name should be "is_" or "has_" (in English) or "on_" 
(in Estonian). Worse: agreed, kinnitatud. Better: is_agreement, 
on_kinnitatud.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">active</td></tr></tbody></table></p><p>Query result generated in 0.007 seconds.</p><p><i>Fixing suggestion:</i> Rename the column.</p><p><i>Seq nr:</i> 22<br><i>Query:</i> <b>Primary key columns are not the first in the table</b><br><i>General goal:</i>
 In SQL tables each column has the ordinal position. Find all the base 
tables where the primary key columns are not the first in the table, 
i.e., there is at least one non-primary key column that comes before a 
primary key column. It is easier to grasp the primary key if its columns
 are the first in the table.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://stackoverflow.com/questions/285733/how-do-i-alter-the-position-of-a-column-in-a-postgresql-database-table">https://stackoverflow.com/questions/285733/how-do-i-alter-the-position-of-a-column-in-a-postgresql-database-table</a></li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">ordinal_position</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_id</td><td class="table_results">6</td></tr></tbody></table></p><p>Query result generated in 0.0099 seconds.</p><p><i>Fixing suggestion:</i>
 Although SQL pays attention to the order of columns in SQL tables it 
does not provide a comfortable way to change the order of columns in the
 table without dropping and recreating the table.</p><p><i>Seq nr:</i> 23<br><i>Query:</i> <b>Do not leave out the referential constraints</b><br><i>General goal:</i>
 Try to find missing foreign key constraints. Find base tables that do 
not participate in any referential constraint (as the referenced table 
or as the referencing table). These tables are like "islands" in the 
database schema.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li>This is one of the antipatterns from the Bill Karwin's book of SQL antipatterns. See Chapter 5: Keyless Entry.</li><li>Rule
 7 in: Delplanque, J., Etien, A., Auverlot, O., Mens, T., Anquetil, N., 
Ducasse, S.: CodeCritics applied to database schema: Challenges and 
first results. In: 2017 IEEE 24th International Conference on Software 
Analysis, Evolution and Reengineering (SANER), pp. 432-436. IEEE, 
(2017).</li><li>Weber, J.H., Cleve, A., Meurice, L., Ruiz, F.J.B.:. 
Managing technical debt in database schemas of critical software. In: 
Sixth International Workshop on Managing Technical Debt, pp. 43-46. IEEE
 (2014).</li><li>Smell "Missing constraints": Sharma, T., Fragkoulis, 
M., Rizou, S., Bruntink, M. and Spinellis, D.: Smelly relations: 
measuring and understanding database schema quality. In: Proceedings of 
the 40th International Conference on Software Engineering: Software 
Engineering in Practice, pp. 55-64. ACM, (2018).</li><li>Mistake (4): <a target="_blank" href="https://www.red-gate.com/simple-talk/sql/database-administration/five-simple--database-design-errors-you-should-avoid/">https://www.red-gate.com/simple-talk/sql/database-administration/five-simple--database-design-errors-you-should-avoid/</a></li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td></tr></tbody></table></p><p>Query result generated in 0.0135 seconds.</p><p><i>Fixing suggestion:</i> Declare foreign key constraints.</p><p><i>Seq nr:</i> 24<br><i>Query:</i> <b>Too many subconditions in a CHECK constraint</b><br><i>General goal:</i>
 Find check constraints of base table and foreign table columns that are
 either associated with more than one column and have at least one AND 
operation or are associated with exactly one column and have two or more
 AND operations.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li>The corresponding code smell in case of cleaning code is "G30: Functions Should Do One Thing". (Robert C. Martin, Clean Code)</li></ul><br>The query found <b><font color="red">2</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">table_type</th><th class="tv_small">column_name</th><th class="tv_small">check_clause</th><th class="tv_small">constraint_name</th><th class="tv_small">check_type</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">check_date</td><td class="table_results">(((comment_text !~ '^[[:space:]]*$'::text) AND (check_date &gt;= CURRENT_TIMESTAMP)))</td><td class="table_results">comment_check</td><td class="table_results">TABLE CHECK</td></tr><tr class="tv2_small"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">comment_text</td><td class="table_results">(((comment_text !~ '^[[:space:]]*$'::text) AND (check_date &gt;= CURRENT_TIMESTAMP)))</td><td class="table_results">comment_check</td><td class="table_results">TABLE CHECK</td></tr></tbody></table></p><p>Query result generated in 0.0169 seconds.</p><p><i>Fixing suggestion:</i>
 Increase separation of concerns in case of CHECK constraints by 
creating multiple smaller check constraints instead of one big 
constraint. Instead of one CHECK constraint with multiple sub-conditions
 create multiple CHECK constraints.</p><p><i>Seq nr:</i> 25<br><i>Query:</i> <b>Textual
 base table and foreign table columns that probably permit empty strings
 and strings that consist of only whitespace characters</b><br><i>General goal:</i>
 Find non-foreign key columns of base tables and foreign tables that 
have a textual type and do not have any CHECK constraint. Such columns 
can contain the empty string and strings that consist of only 
whitespace.<br><i>Goal in the test:</i> <b>If exists, then very suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://en.wikipedia.org/wiki/Whitespace_character">https://en.wikipedia.org/wiki/Whitespace_character</a></li></ul><br>The query found <b><font color="red">2</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th><th class="tv">character_maximum_length</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_text</td><td class="table_results">text</td><td class="table_results">&nbsp;</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">first_name</td><td class="table_results">character varying</td><td class="table_results">50</td></tr></tbody></table></p><p>Query result generated in 0.0236 seconds.</p><p><i>Fixing suggestion:</i>
 Add the check constraint to the column. If the column has been defined 
based on a domain, then add the constraint to the domain.<br><i>A fixing action:</i> Add the constraint directly to the table column.<br><textarea readonly="readonly" cols="100" rows="2" wrap="off">ALTER TABLE public.comment ADD CONSTRAINT chk_comment_comment_text CHECK(comment_text!~'^[[:space:]]*$');
ALTER TABLE public.public_person_data ADD CONSTRAINT chk_public_person_data_first_name CHECK(first_name!~'^[[:space:]]*$');</textarea></p><p><i>Seq nr:</i> 26<br><i>Query:</i> <b>Cannot register all legal personal names</b><br><i>General goal:</i>
 Find CHECK constraints on base table or foreign table columns that 
contain data about personal names and apply unnecessary restrictions to 
the names, rejecting potentially some legal names.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/">https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/</a></li><li><a target="_blank" href="https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/">https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/</a></li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">table_type</th><th class="tv_small">column_name</th><th class="tv_small">check_clause</th><th class="tv_small">constraint_name</th><th class="tv_small">check_type</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">last_name</td><td class="table_results">(((last_name)::text !~ '[[:digit:]]'::text))</td><td class="table_results">chk_person_data_last_name2</td><td class="table_results">TABLE CHECK</td></tr></tbody></table></p><p>Query result generated in 0.0141 seconds.</p><p><i>Fixing suggestion:</i> Drop the constraints.<br><i>A fixing action:</i> Drop the base table constraint.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.public_person_data DROP CONSTRAINT chk_person_data_last_name2;</textarea></p><p><i>Seq nr:</i> 27<br><i>Query:</i> <b>Temporal columns that probably permit values that may be outside the range of logical values</b><br><i>General goal:</i>
 Find base tables columns with temporal types (date and timestamp) that 
do not belong to a foreign key and that do not have any associated CHECK
 constraints. For instance, in the column <i>registration_time</i> that 
does not have any associated CHECK constraints could be values 
'1200-01-01 00:00' or '5900-12-31 00:00'. Rows with these values most 
probably represent wrong propositions and the system should restrict 
registration of such data.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">3</font></b> rows!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">check_date</td><td class="table_results">timestamp without time zone</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_registration_time</td><td class="table_results">timestamp without time zone</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">registration_time</td><td class="table_results">timestamp with time zone</td></tr></tbody></table></p><p>Query result generated in 0.0198 seconds.</p><p><i>Fixing suggestion:</i> Add a CHECK constraint to the column that further (in addition to the data type) restricts values in the column.</p><p><i>Seq nr:</i> 28<br><i>Query:</i> <b>Perhaps a CHECK constraint about the order of events is missing</b><br><i>General goal:</i>
 Find base tables that have at least two columns that have DATE or 
TIMESTAMP (with or without time zone) type and do not have any 
associated CHECK constraint that involves two or more of these columns. 
The columns mean that we want to record data about events or processes, 
which often have a certain order. Hence, in case of each row of such a 
table the values in these columns must be in a certain order. For 
instance, the end of a meeting cannot be earlier than the beginning of 
the meeting.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td></tr></tbody></table></p><p>Query result generated in 0.0509 seconds.</p><p><i>Fixing suggestion:</i> Add relevant CHECK constraints.</p><p><i>Seq nr:</i> 29<br><i>Query:</i> <b>Duplication of parent table CHECK constraints on the foreign key columns</b><br><i>General goal:</i>
 Find duplicate constraints, which make it more difficult to maintain 
the constraints. Do remember that the same task can be solved in SQL 
usually in multiple different ways. Thus, the exact copies are not the 
only possible duplication.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://refactoring.guru/smells/alternative-classes-with-different-interfaces">https://refactoring.guru/smells/alternative-classes-with-different-interfaces</a></li><li><a target="_blank" href="https://refactoring.guru/smells/duplicate-code">https://refactoring.guru/smells/duplicate-code</a></li><li>The corresponding code smell in case of cleaning code is "G5: Duplication". (Robert C. Martin, Clean Code)</li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">foreign_schema</th><th class="tv_small">foreign_table</th><th class="tv_small">foreign_colname</th><th class="tv_small">target_schema</th><th class="tv_small">target_table</th><th class="tv_small">target_colname</th><th class="tv_small">check_on_target_column</th><th class="tv_small">check_type</th><th class="tv_small">domain_schema_target</th><th class="tv_small">domain_name_target</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">person_state_type_code</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">persons_state_type_code</td><td class="table_results">((VALUE &gt; 0))</td><td class="table_results">TABLE CHECK</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td></tr></tbody></table></p><p>Query result generated in 0.0149 seconds.</p><p><i>Fixing suggestion:</i>
 Drop the check constraint from the foreign key columns. If the foreign 
column is associated with a domain, then one may want to consider 
removing the domain from the column and associating the column directly 
with a data type.<br><i>A fixing action:</i> Drop the constraint.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.public_person_data DROP CONSTRAINT chk_code;</textarea></p><p><i>Seq nr:</i> 30<br><i>Query:</i> <b>Incorrect use of non-deterministic functions in CHECK constraints</b><br><i>General goal:</i>
 Do not create a constraint in case of which data that satisfied a 
constraint c at the registration time suddenly does not satisfy it any 
more as the time goes by. Find all the check constraints that use 
non-deterministic functions (now, current_timestamp, localtimestamp, 
current_date, current_time) in a way that makes this situation possible.
 Fort instance, <b>localtimestamp(0)&gt;end_date</b> is an example of such constraint.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">2</font></b> rows!</p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">table_type</th><th class="tv_small">column_name</th><th class="tv_small">check_clause</th><th class="tv_small">constraint_name</th><th class="tv_small">check_type</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">check_date</td><td class="table_results">(((comment_text !~ '^[[:space:]]*$'::text) AND (check_date &gt;= CURRENT_TIMESTAMP)))</td><td class="table_results">comment_check</td><td class="table_results">TABLE CHECK</td></tr><tr class="tv2_small"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">BASE TABLE</td><td class="table_results">comment_text</td><td class="table_results">(((comment_text !~ '^[[:space:]]*$'::text) AND (check_date &gt;= CURRENT_TIMESTAMP)))</td><td class="table_results">comment_check</td><td class="table_results">TABLE CHECK</td></tr></tbody></table></p><p>Query result generated in 0.0119 seconds.</p><p><i>Fixing suggestion:</i> Drop the constraints. Implement the checks by using triggers, user-defined routines, or in the application.<br><i>A fixing action:</i> Drop the constraint that is associated directly with the table.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.comment DROP CONSTRAINT comment_check;</textarea></p><p><i>Seq nr:</i> 31<br><i>Query:</i> <b>Incorrect prevention of the empty string or strings that consist of only spaces in a field</b><br><i>General goal:</i>
 Find columns of base tables and foreign tables where the requirement 
that there should not be empty strings or strings that consist of only 
spaces in the column has been implemented incorrectly - by using the 
constraint <b>trim(column_name) IS NOT NULL</b>. PostgreSQL (differently
 from Oracle) does not replace the empty string with NULL. Empty string 
is a value but NULL is a special marker that denotes a missing value. 
Thus, in case of such constraint the DBMS checks a proposition <b>'' IS NOT NULL</b>. This is a true proposition and the DBMS does not prevent registration of such a row.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">table_type</th><th class="tv_small">column_name</th><th class="tv_small">check_clause</th><th class="tv_small">constraint_name</th><th class="tv_small">check_type</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">BASE TABLE</td><td class="table_results">last_name</td><td class="table_results">((btrim((last_name)::text) IS NOT NULL))</td><td class="table_results">chk_person_data_last_name</td><td class="table_results">TABLE CHECK</td></tr></tbody></table></p><p>Query result generated in 0.0111 seconds.</p><p><i>Fixing suggestion:</i> Use instead the constraint <b>trim(column_name)&lt;&gt;''</b>.
 Also make sure as to whether there is instead a rule that prevents 
strings that consist of only whitespace characters in the column. If it 
is, then instead use the following constraint: <b>(column_name|VALUE)!~'^[[:space:]]*$'</b>.<br><i>A fixing action:</i> Drop the constraint that is directly associated with the table.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.public_person_data DROP CONSTRAINT chk_person_data_last_name;</textarea><br><i>A fixing action:</i> Add the constraint that is directly associated with the table.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.public_person_data ADD CONSTRAINT chk_person_data_last_name CHECK (trim(last_name)&lt;&gt;'');</textarea></p><p><i>Seq nr:</i> 32<br><i>Query:</i> <b>Preventing strings that consist of only spaces instead of strings that consist of only whitespace characters</b><br><i>General goal:</i>
 Find columns of base tables where one uses a check constraint to 
prevent values that consist of only spaces. Make sure that this is the 
correct constraint and there is no need to prevent values that consist 
of only whitespace characters.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">table_type</th><th class="tv_small">column_name</th><th class="tv_small">check_clause</th><th class="tv_small">constraint_name</th><th class="tv_small">check_type</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">BASE TABLE</td><td class="table_results">name</td><td class="table_results">((btrim((name)::text) &lt;&gt; ''::text))</td><td class="table_results">chk_person_state_type_name</td><td class="table_results">TABLE CHECK</td></tr></tbody></table></p><p>Query result generated in 0.0108 seconds.</p><p><i>Fixing suggestion:</i>
 If there is instead a rule that prevents strings that consist of only 
whitespace characters in the column, then instead use the following 
constraint: <b>(column_name|VALUE)!~'^[[:space:]]*$'</b>.<br><i>A fixing action:</i> Drop the constraint that is directly associated with the table.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.person_state_type DROP CONSTRAINT chk_person_state_type_name;</textarea></p><p><i>Seq nr:</i> 33<br><i>Query:</i> <b>Optional base table columns that have a default value</b><br><i>General goal:</i> Find optiona base table columns that have a default value. Such columns should be mandatory.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">column_name</th><th class="tv_small">data_type</th><th class="tv_small">domain_name</th><th class="tv_small">domain_schema</th><th class="tv_small">column_default</th><th class="tv_small">domain_default</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_registration_time</td><td class="table_results">timestamp without time zone</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td><td class="table_results">CURRENT_TIMESTAMP</td><td class="table_results">&nbsp;</td></tr></tbody></table></p><p>Query result generated in 0.0362 seconds.</p><p><i>Fixing suggestion:</i>
 Declare NOT NULL constraint either directly to the column or to the 
domain of the column. Do not declare the NOT NULL constraint to both 
column and domain.<br><i>A fixing action:</i> Declare NOT NULL constraint to the column.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.comment ALTER COLUMN comment_registration_time SET NOT NULL;</textarea></p><p><i>Seq nr:</i> 34<br><i>Query:</i> <b>Mandatory columns for holding large textual values (comments, descriptions, etc.)</b><br><i>General goal:</i>
 Find mandatory (NOT NULL) base table columns that name, column type, 
and field size refers to the possibility that these are used to register
 large textual values like comments, descriptions, and explanations.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th><th class="tv">character_maximum_length</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_text</td><td class="table_results">text</td><td class="table_results">&nbsp;</td></tr></tbody></table></p><p>Query result generated in 0.0114 seconds.</p><p><i>Fixing suggestion:</i> Be precise. Are you sure you have such value for each row. Perhaps, the NOT NULL constraint should be dropped.</p><p><i>Seq nr:</i> 35<br><i>Query:</i> <b>All the non-primary key columns are optional</b><br><i>General goal:</i>
 Avoid too many optional columns. You have to be extra careful with 
NULLs in case of formulating search conditions of data manipulation 
statements.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">person_state_type</td></tr></tbody></table></p><p>Query result generated in 0.1186 seconds.</p><p><i>Fixing suggestion:</i>
 Increase the number of columns that have NOT NULL constraint. It means 
going back to the requirements and finding out as to whether some 
attribute or relationship type of an entity type is actually mandatory. A
 problem is that you cannot add the NOT NULL constraint to a column that
 already has NULLs in it. In this case you can add a CHECK constraint 
with the NOT VALID state. "If the constraint is marked NOT VALID, the 
potentially-lengthy initial check to verify that all rows in the table 
satisfy the constraint is skipped. The constraint will still be enforced
 against subsequent inserts or updates (that is, they'll fail unless 
there is a matching row in the referenced table, in the case of foreign 
keys; and they'll fail unless the new row matches the specified check 
constraints). But the database will not assume that the constraint holds
 for all rows in the table, until it is validated by using the VALIDATE 
CONSTRAINT option." (<a target="_blank" href="https://www.postgresql.org/docs/current/sql-altertable.html">https://www.postgresql.org/docs/current/sql-altertable.html</a><br><i>A fixing action:</i> Add the NOT NULL constraint. Most probably only a subset of the statements has to be executed.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.person_state_type ALTER COLUMN name SET NOT NULL;</textarea><br><i>A fixing action:</i> Add the NOT VALID CHECK constraint. Most probably only a subset of the statements has to be executed.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.person_state_type ADD CONSTRAINT chk_person_state_type_name CHECK (name IS NOT NULL) NOT VALID;</textarea></p><p><i>Seq nr:</i> 36<br><i>Query:</i> <b>Base table column of personal names has questionable properties</b><br><i>General goal:</i>
 Find base table columns that name refers to the possibility that these 
are used to register personal names. There are very long names. There 
are persons who only have one name (mononymous persons). Database design
 must take into account and allow registration of such names as well in a
 database.<br><i>Goal in the test:</i> <b>If exists, then suspicious.</b><br><i>Reliability of the results:</i> Low (Many false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://en.wikipedia.org/wiki/Hubert_Blaine_Wolfeschlegelsteinhausenbergerdorff_Sr.">https://en.wikipedia.org/wiki/Hubert_Blaine_Wolfeschlegelsteinhausenbergerdorff_Sr.</a></li><li><a target="_blank" href="https://en.wikipedia.org/wiki/Mononymous_person">https://en.wikipedia.org/wiki/Mononymous_person</a></li><li><a target="_blank" href="https://digi.lib.ttu.ee/i/?7072">https://digi.lib.ttu.ee/i/?7072</a></li><li><a target="_blank" href="https://digikogu.taltech.ee/et/Item/ab7e8f7e-ce28-4cc1-bb78-40c624d19bf6">https://digikogu.taltech.ee/et/Item/ab7e8f7e-ce28-4cc1-bb78-40c624d19bf6</a></li></ul><br>The query found <b><font color="red">2</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">column_name</th><th class="tv_small">data_type</th><th class="tv_small">character_maximum_length</th><th class="tv_small">comment_length</th><th class="tv_small">is_nullable</th><th class="tv_small">comment_nullable</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">first_name</td><td class="table_results">character varying</td><td class="table_results">50</td><td class="table_results">What about very long names!</td><td class="table_results">NO</td><td class="table_results">What about mononymous persons!</td></tr><tr class="tv2_small"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">last_name</td><td class="table_results">character varying</td><td class="table_results">50</td><td class="table_results">What about very long names!</td><td class="table_results">NO</td><td class="table_results">What about mononymous persons!</td></tr></tbody></table></p><p>Query result generated in 0.0079 seconds.</p><p><i>Fixing suggestion:</i> Increase the field size of the column. In case of having columns <i>given name</i> and <i>surname</i>
 and either a) make both columns optional (permit NULLs) and declare a 
CHECK constraint that in case of each row at least one of these values 
must be registered or b) make column <i>given name</i> mandatory (NOT NULL) and <i>surname</i> optional (permits NULLs).</p><p><i>Seq nr:</i> 37<br><i>Query:</i> <b>Lifecycle not initiated</b><br><i>General goal:</i>
 Find non-primary key and non-unique base table columns that name refers
 to the possibility that these are used to register references to a 
state classifier. The column must belong to a foreign key and does not 
have a default value.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">persons_state_type_code</td></tr></tbody></table></p><p>Query result generated in 0.0191 seconds.</p><p><i>Fixing suggestion:</i>
 Declare to the column a default value that corresponds to the first 
state that the entity gets after its data is registered in the system.</p><p><i>Seq nr:</i> 38<br><i>Query:</i> <b>Columns of base tables that have type BOOLEAN but do not have a default value</b><br><i>General goal:</i>
 There are only two truth values - TRUE and FALSE - in case of 
two-valued logic. It should be possible to select one of these as the 
default value of a column that has BOOLEAN type.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">active</td></tr></tbody></table></p><p>Query result generated in 0.0145 seconds.</p><p><i>Fixing suggestion:</i>
 Determine as to whether there is markedly higher probability that a new
 row has one of the truth-values. If yes, then declare a default value. 
The default value can be directly associated with a column or it could 
be associated with a domain (if the column has been defined based on the
 domain).</p><p><i>Seq nr:</i> 39<br><i>Query:</i> <b>Inconsistency between the type and the default value in case of table columns with timestamp/date data</b><br><i>General goal:</i> Find table columns with timestamp/date types that data type and dynamically found default value have a different type<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_type</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th><th class="tv">def</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">BASE TABLE</td><td class="table_results">comment</td><td class="table_results">comment_registration_time</td><td class="table_results">timestamp without time zone</td><td class="table_results">CURRENT_TIMESTAMP</td></tr></tbody></table></p><p>Query result generated in 0.0096 seconds.</p><p><i>Fixing suggestion:</i> Change the default value or the data type of the column.</p><p><i>Seq nr:</i> 40<br><i>Query:</i> <b>Do you really need fractional seconds?</b><br><i>General goal:</i> Find default values that return current timestamp with the maximum number of fractional seconds (6).<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Low (Many false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">table_schema</th><th class="tv_small">table_name</th><th class="tv_small">column_name</th><th class="tv_small">data_type</th><th class="tv_small">domain_schema</th><th class="tv_small">domain_name</th><th class="tv_small">default_value</th><th class="tv_small">default_type</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_registration_time</td><td class="table_results">timestamp without time zone</td><td class="table_results">&nbsp;</td><td class="table_results">&nbsp;</td><td class="table_results">CURRENT_TIMESTAMP</td><td class="table_results">Column default</td></tr></tbody></table></p><p>Query result generated in 0.0138 seconds.</p><p><i>Fixing suggestion:</i>
 If you do not need fractional seconds or do not need the maximum number
 of fractional seconds, then do not use function now() and invoke 
functions LOCALTIMESTAMP, CURRENT_TIMESTAMP, LOCALTIME, and CURRENT_TIME
 with an argument that determines the fractional seconds precision (for 
instance, LOCALTIMESTAMP(0)).</p><p><i>Seq nr:</i> 41<br><i>Query:</i> <b>Mixing different mechanisms to generate surrogate values</b><br><i>General goal:</i>
 Use the same mechanism of generating surrogate key values throughout 
the database. The use of SERIAL notation/explicitly creating a sequence 
generator and declaration of a column as an identity column will cause 
the creation of an external and internal sequence generator, 
respectively. Nevertheless, one should try to stick with using one of 
the mechanisms in order to cause less confusion. "If you do something a 
certain way, do all similar things in the same way." (Robert C. Martin, 
Clean Code)<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br><i>Reference materials:</i> </p><ul><li>The corresponding code smell in case of cleaning code is "G11: Inconsistency". (Robert C. Martin, Clean Code)</li></ul><br>The query found <b><font color="red">2</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">column_default</th><th class="tv">is_identity</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_id</td><td class="table_results">nextval('comment_comment_id_seq'::regclass)</td><td class="table_results">NO</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">id</td><td class="table_results">&nbsp;</td><td class="table_results">YES</td></tr></tbody></table></p><p>Query result generated in 0.0158 seconds.</p><p><i>Fixing suggestion:</i> Choose one mechanism (SERIAL, identity columns) and use it consistently.</p><p><i>Seq nr:</i> 42<br><i>Query:</i> <b>Inconsistency of using column data types/field sizes in case of columns that implement relationships</b><br><i>General goal:</i>
 Primary key/unique columns and foreign key columns should have the same
 data type and field size. If, for instance, the primary key column has 
type INTEGER and foreign key column has type SMALLINT, then one cannot 
use all the primary key values as foreign key values.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">conname</th><th class="tv_small">foreign_schema</th><th class="tv_small">foreign_table</th><th class="tv_small">foreign_col</th><th class="tv_small">target_schema</th><th class="tv_small">target_table</th><th class="tv_small">target_col</th><th class="tv_small">foreign_data_type</th><th class="tv_small">target_data_type</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">FK_person person_state_type</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">person_state_type_code</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">persons_state_type_code</td><td class="table_results">integer</td><td class="table_results">smallint</td></tr></tbody></table></p><p>Query result generated in 0.0319 seconds.</p><p><i>Fixing suggestion:</i> Change the types or field sizes of the primary key/unique columns or the foreign key columns.</p><p><i>Seq nr:</i> 43<br><i>Query:</i> <b>Should the time zone be recorded in case of timestamp or not?</b><br><i>General goal:</i> Find all the base table columns that have the type timestamp <b>without time zone</b> or timestamp <b>with time zone</b>.
 Return the data only if there is at least one column with the type 
timestamp without time zone and one column with the type timestamp with 
time zone.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">3</font></b> rows!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">comment_registration_time</td><td class="table_results">timestamp without time zone</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">check_date</td><td class="table_results">timestamp without time zone</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">registration_time</td><td class="table_results">timestamp with time zone</td></tr></tbody></table></p><p>Query result generated in 0.0059 seconds.</p><p><i>Seq nr:</i> 44<br><i>Query:</i> <b>Inconsistencies between column names and types of base table columns (temporal data)</b><br><i>General goal:</i>
 Find base table columns that name refers to the possibility that these 
are used to register temporal data. Find the columns that do not have an
 appropriate data type. Column names should reflect the data that is 
possible to record in the column. For instance, in case of temporal data
 the column name should indicate as to whether we record dates or 
timestamps. If the column data type is "date", then the suffix of the 
column name should be "kp" (Estonian) or "date" (English). If the column
 type is "timestamp", then the suffix of the column name should be "aeg"
 (Estonian) or "time" (English).<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th><th class="tv">data_type</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">check_date</td><td class="table_results">timestamp without time zone</td></tr></tbody></table></p><p>Query result generated in 0.0057 seconds.</p><p><i>Fixing suggestion:</i> Rename the column or change the type of the column.</p><p><i>Seq nr:</i> 45<br><i>Query:</i> <b>ON UPDATE CASCADE is probably missing</b><br><i>General goal:</i>
 Find foreign key constraints that do not feature ON UPDATE CASCADE 
compensating action although people have a reason to change the key 
value in the primary table by assuming that the names of columns 
correctly point towards the use of natural keys in the table.<br><i>Goal in the test:</i> <b>If exists, then suspicious; Assumes that your column names consistently differentiate between "_code" and "_id".</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv_small">nr</th><th class="tv_small">foreign_schema</th><th class="tv_small">foreign_table</th><th class="tv_small">foreign_column_name</th><th class="tv_small">target_schema</th><th class="tv_small">target_table</th><th class="tv_small">target_column_name</th><th class="tv_small">constraint_name</th><th class="tv_small">update_compensating_action</th></tr><tr class="tv1_small"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">person_state_type_code</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">persons_state_type_code</td><td class="table_results">FK_person person_state_type</td><td class="table_results">ON UPDATE NO ACTION</td></tr></tbody></table></p><p>Query result generated in 0.0025 seconds.</p><p><i>Fixing suggestion:</i> Drop the foreign key constraint and recreate it with ON UPDATE CASCADE compensating action.<br><i>A fixing action:</i> Drop the foreign key constraint.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.public_person_data DROP CONSTRAIN "FK_person person_state_type";</textarea></p><p><i>Seq nr:</i> 46<br><i>Query:</i> <b>Foreign key columns that have no index</b><br><i>General goal:</i>
 Find foreign key columns that do not have an index. Foreign key columns
 are often used for performing join operations. It is useful to index 
such columns.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://www.cybertec-postgresql.com/en/index-your-foreign-key/">https://www.cybertec-postgresql.com/en/index-your-foreign-key/</a></li><li>Smell
 "Index abuse": Sharma, T., Fragkoulis, M., Rizou, S., Bruntink, M. and 
Spinellis, D.: Smelly relations: measuring and understanding database 
schema quality. In: Proceedings of the 40th International Conference on 
Software Engineering: Software Engineering in Practice, pp. 55-64. ACM, 
(2018).</li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">conname</th><th class="tv">fk_schema</th><th class="tv">fk_table</th><th class="tv">fk_col</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">FK_person person_state_type</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">persons_state_type_code</td></tr></tbody></table></p><p>Query result generated in 0.0036 seconds.</p><p><i>Fixing suggestion:</i> Create index to the foreign key.</p><p><i>Seq nr:</i> 47<br><i>Query:</i> <b>Insufficient routine privileges</b><br><i>General goal:</i> You must give rights to use routines to the users/roles that correspond to applications.<br><i>Goal in the test:</i> <b>There should not be any. See exercise 12 for detais.</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">comment</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">You must give rights to use routines to the users/roles that correspond to applications</td></tr></tbody></table></p><p>Query result generated in 0.0131 seconds.</p><p><i>Seq nr:</i> 48<br><i>Query:</i> <b>Insufficient view privileges</b><br><i>General goal:</i> You must give privileges to use views to the users/roles that correspond to applications<br><i>Goal in the test:</i> <b>There should not be any. See exercise 12 for detais.</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br>The query found <b><font color="red">1</font></b> row!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">comment</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">You must give rights to use views to the users/roles that correspond to applications</td></tr></tbody></table></p><p>Query result generated in 0.0084 seconds.</p><p><i>Seq nr:</i> 49<br><i>Query:</i> <b>Empty tables</b><br><i>General goal:</i>
 Find base tables where the number of rows is zero. If there are no rows
 in a table, then it may mean that one hasn't tested constraints that 
have been declared to the table or implemented by using triggers. It 
could also mean that the table is not needed because there is no data 
that should be registered in the table.<br><i>Goal in the test:</i> <b>There should not be any. If there is at least one table with zero rows, then complete exercise 5.</b><br><i>Reliability of the results:</i> High (Few or no false-positive results)<br>The query found <b><font color="red">3</font></b> rows!</p><p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">schema_name</th><th class="tv">table_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">person_state_type</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td></tr></tbody></table></p><p>Query result generated in 0.1159 seconds.</p><p><i>Fixing suggestion:</i> Drop the table or start to use it.<br><i>A fixing action:</i> Drop the table.<br><textarea readonly="readonly" cols="100" rows="3" wrap="off">DROP TABLE public.comment;
DROP TABLE public.person_state_type;
DROP TABLE public.public_person_data;</textarea></p><p><i>Seq nr:</i> 50<br><i>Query:</i> <b>FILLFACTOR is probably too big</b><br><i>General goal:</i>
 Find base tables in case of which the FILLFACTOR property has perhaps a
 too high value. Try to find base tables that probably encounter UPDATE 
operations. In the tables that have frequent updates you want to have 
free space in table pages (blocks) to accommodate new row versions, 
which the system automatically creates as the result of fulfilling 
UPDATE statements. If a new row version will be put to another page by 
the system, then it means that table indexes have to be updated as well.
 Thus, the more there are indexes, the more the table would benefit from
 keeping a new row version in the same page as the old version.<br><i>Goal in the test:</i> <b>If exists, then suspicious. See exercise 4 for details.</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://www.dbrnd.com/2016/03/postgresql-the-awesome-table-fillfactor-to-speedup-update-and-select-statement/">https://www.dbrnd.com/2016/03/postgresql-the-awesome-table-fillfactor-to-speedup-update-and-select-statement/</a></li><li><a target="_blank" href="http://blog.coelho.net/database/2014/08/23/postgresql-fillfactor-and-update.html">http://blog.coelho.net/database/2014/08/23/postgresql-fillfactor-and-update.html</a></li></ul><br>The query found <b><font color="red">3</font></b> rows!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">indications_that_the_table_will_be_updated</th><th class="tv">the_number_of_different_indications</th><th class="tv">number_of_indexes</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">Contains boolean columns;Contains long textual columns;Contains optional columns</td><td class="table_results">3</td><td class="table_results">1</td></tr><tr class="tv2"><td class="table_results">2</td><td class="table_results">public</td><td class="table_results">person_state_type</td><td class="table_results">Contains optional columns</td><td class="table_results">1</td><td class="table_results">1</td></tr><tr class="tv1"><td class="table_results">3</td><td class="table_results">public</td><td class="table_results">public_person_data</td><td class="table_results">Have state classifier</td><td class="table_results">1</td><td class="table_results">1</td></tr></tbody></table></p><p>Query result generated in 0.0643 seconds.</p><p><i>Fixing suggestion:</i>
 Change FILLFACTOR to 90 or 95. It does not have to be smaller because 
old versions of rows will be soon deleted from blocks by the vacuum 
process, i.e., it frees space.<br><i>A fixing action:</i> Change the fillfactor to 90.<br><textarea readonly="readonly" cols="100" rows="3" wrap="off">ALTER TABLE public.comment SET (FILLFACTOR=90);
ALTER TABLE public.person_state_type SET (FILLFACTOR=90);
ALTER TABLE public.public_person_data SET (FILLFACTOR=90);</textarea></p><p><i>Seq nr:</i> 51<br><i>Query:</i> <b>Perhaps a too simplified state machine</b><br><i>General goal:</i>
 Find base table columns with Boolean type that name refers to the 
possibility that these are used to register as to whether an entity is 
currently in active state or not. Find the base tables that have exactly
 one Boolean column. During the system design one should find all the 
possible states of an entity type that influence the behavior of the 
information system. Data as to whether an entity is in one of these 
states should be in the database. Having only two states - 
active/inactive - is sometimes a too big simplification.<br><i>Goal in the test:</i> <b>If exists, then suspicious</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li>L.
 Silverston ja P. Agnew, „The Data Model Resource Book, Volume 3: 
Universal Patterns for Data Modeling,“ Chichester, John Wiley &amp; Sons
 Ltd, 2009. Level 1 status pattern.</li><li><a target="_blank" href="https://softwareengineering.stackexchange.com/questions/214940/how-to-handle-status-columns-in-designing-tables">https://softwareengineering.stackexchange.com/questions/214940/how-to-handle-status-columns-in-designing-tables</a></li><li><a target="_blank" href="https://www.percona.com/blog/2008/08/09/picking-datatype-for-status-feilds/">https://www.percona.com/blog/2008/08/09/picking-datatype-for-status-feilds/</a></li><li><a target="_blank" href="https://stackoverflow.com/questions/5724593/table-with-many-boolean-status-fields">https://stackoverflow.com/questions/5724593/table-with-many-boolean-status-fields</a></li><li><a target="_blank" href="https://digikogu.taltech.ee/et/Item/101f40e2-d9fe-4bef-ab25-54508f18c078">https://digikogu.taltech.ee/et/Item/101f40e2-d9fe-4bef-ab25-54508f18c078</a></li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">active</td></tr></tbody></table></p><p>Query result generated in 0.0065 seconds.</p><p><i>Seq nr:</i> 52<br><i>Query:</i> <b>Three-valued logic</b><br><i>General goal:</i>
 Find base table columns that have Boolean type and do not have NOT NULL
 constraint. Use two-valued logic (TRUE, FALSE) instead of three-valued 
logic (TRUE, FALSE, UNKNOWN). Because NULL in a Boolean column means 
unknown make all the Boolean columns mandatory.<br><i>Goal in the test:</i> <b>There should not be any</b><br><i>Reliability of the results:</i> Medium (Medium number of false-positive results)<br><i>Reference materials:</i> </p><ul><li><a target="_blank" href="https://thoughtbot.com/blog/avoid-the-threestate-boolean-problem">https://thoughtbot.com/blog/avoid-the-threestate-boolean-problem</a></li></ul><br>The query found <b><font color="red">1</font></b> row!<p><table class="table_results"><tbody><tr><th class="tv">nr</th><th class="tv">table_schema</th><th class="tv">table_name</th><th class="tv">column_name</th></tr><tr class="tv1"><td class="table_results">1</td><td class="table_results">public</td><td class="table_results">comment</td><td class="table_results">active</td></tr></tbody></table></p><p>Query result generated in 0.0177 seconds.</p><p><i>Fixing suggestion:</i> Make the column mandatory by declaring NOT NULL constraint to it.<br><i>A fixing action:</i> Apply the NOT NUL L constraint directly to the column.<br><textarea readonly="readonly" cols="100" rows="1" wrap="off">ALTER TABLE public.comment ALTER COLUMN active SET NOT NULL</textarea></p><p>Page generated in 7.7185 seconds.</p><p><a href="#top">Top</a></p></div>


</body></html>